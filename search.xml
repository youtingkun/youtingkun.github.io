<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树相关]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[创建 function Node(data,left,right){ this.data = data;//数值 this.left = left;//左节点 this.right = right;//右节点 }; 插入二叉树 function insert(node,data){ //创建一个新的节点 let newNode = new Node(data,null,null); //判断是否存在根节点，没有将新节点存入 if(node == null){ node = newNode; }else{ //获取根节点 let current = node; let parent; while(true){ //将当前节点保存为父节点 parent = current; //将小的数据放在左节点 if(data &lt; current.data){ //获取当前节点的左节点 //判断当前节点下的左节点是否有数据 current = current.left; if(current == null){ //如果没有数据将新节点存入当前节点下的左节点 parent.left = newNode; break; } }else{ current = current.right; if(current == null){ parent.right = newNode; break; } } } } } 翻转二叉树 function invertTree(node) { if (node !== null) { node.left, node.right = node.left, node.right; invertTree(node.left); invertTree(node.right); } return node; }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现常用排序]]></title>
    <url>%2F2018%2F11%2F21%2FJavaScript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一、冒泡排序//相邻两个数之间进行排序 //外层长度为length //内层长度为length-1-i,因为内层比较的时候会j+1，所以这里是length-1 //第一次内层循环完会把最大的一个数放在最后，然后又从第一位开始循环。 function bubbleSort(arr){ for(let i = 0; i &lt; arr.length; i++){ for(let j = 0; j &lt; arr.length-1-i; j++){ if(arr[j]&gt;arr[j+1]){ let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } return arr } 二、选择排序//内层每循环完一次会找出最小的数 //外层长度为length-1,因为内层j=i+1 //第一次循环会把最小的数放在最前面,然后从下一位开始循环 function selectSort(arr){ for(let i = 0; i &lt; arr.length-1; i++){ let minIndex = i; for(let j = i +1; j &lt; arr.length; j++){ if(arr[j]&lt;arr[minIndex]){ minIndex = j; } } let temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; //在最小的数所在的位置，设置为查找的第一个数 } return arr; } 三、插入排序//current为拿出去缓存的数 //如果current前面的数比它大，会把这个数向后移动一位。然后再比较前一位与current的大小 //第一次循环，会判断第二个数，也就是缓存的数在前两位数组中大小的位置。然后再比较第三个数在前三位数组中大小的位置。 function insertSort(arr){ for(let i = 1; i &lt; arr.length; i++){ let current = arr[i]; let preIndex = i-1; while(preIndex &gt;=0; arr[preIndex] &gt; current){ arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } 四、快速排序//先设置一个中间值 //把小于中间值的放在左边，把大于中间值的放在右边 //重复前面两个步骤 function quickSort(arr){ if(arr.length &lt;=1 ){ return arr; } let pivotIndex = Math.floor(arr.length/2); let pivot = arr.splice(pivotIndex,1); //截取中间值，如果此处使用pivot=arr[index]; 那么将会出现无限递归的错误 let left = []; let right = []; for(let i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; pivot){ left.push(arr[i]); }else{ right.push(arr[i]); } } return quickSort(left).concat(pivot,quickSort(right)); } 五、归并排序//归并排序是一种分治算法。 //本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置。 //接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 function mergeSort(arr) { let len = arr.length; if(len &lt; 2) { return arr; } let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right){ let result = []; while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } result.push(...left); result.push(...right); return result; } 六、堆排序1）索引0是树的根节点； 2）除根节点为，任意节点N的父节点是N/2； 3）节点L的左子节点是2*L； 4）节点R的右子节点为2*R + 1 // 本质上就是先构建二叉树，然后把根节点与最后一个进行交换， //然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { //建立大顶堆 len = arr.length; for (let i = Math.floor(len / 2); i &gt;= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { //堆调整 let left = 2 * i + 1; let right = 2 * i + 2; let largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if (largest !== i) { [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(arr, largest); } } function heapSort(arr) { buildMaxHeap(arr); for (let i = arr.length - 1; i &gt; 0; i--) { [arr[0],arr[i]]=[arr[i],arr[0]]; len--; heapify(arr, 0); } return arr; } 七、二分查找（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。 （2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。 （3）如果某一步数组为空，则表示找不到目标元素。 function binary_search(arr, key) { let low = 0; let high = arr.length - 1; while(low &lt;= high){ let mid = parseInt((high + low) / 2); if(key === arr[mid]){ return mid; }else if(key &gt; arr[mid]){ low = mid + 1; }else if(key &lt; arr[mid]){ high = mid -1; }else{ return -1; } } }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用布局实现]]></title>
    <url>%2F2018%2F11%2F01%2Fcss%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[布局方式1.标准文档流 2.浮动布局 其它盒子在定位的时候，会忽略浮动布局定位的元素，但是其它盒子内的文本依然会为这个元素让出位置，环绕在四周。 3.定位布局值为static和relative时不会脱离文档流。 值为absolute和fixed时元素会脱离文档流。 绝对定位时，其它盒子在定位时，也会忽略绝对定位的元素，而且其它盒子内的文本也会忽略这个元素。 4.flex布局概念：main axis（主轴）,cross axis（交叉轴）,container(父容器)，item（子容器）。 父容器属性：设置主轴的方向: flex-direction: row //向右，默认 column //向下 row-reverse //向左 column-reverse //向上 设置所有子容器怎样沿主轴排列（横轴）： justify-content: flex-start //起始端对齐 flex-end //末尾端对齐 center //居中对齐 space-around //子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。 space-between //子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。 设置所有子容器怎样沿交叉轴排列（纵轴）： align-items： flex-start //起始端对齐 flex-end //末尾端对齐 center //居中对齐 baseline //基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。 stretch //子容器沿纵轴方向的尺寸拉伸至与父容器一致。 设置所有子容器换行方式： flex-wrap: nowrap //不换行 wrap //换行 wrap-reverse //逆序换行 轴与换行组合： flex-flow: 当子容器多行排列时，设置行与行之间的对齐方式。： align-content: flex-start flex-end center baseline stretch 子容器属性设置单个子容器在主轴上如何伸缩： flex: 单值（flex-grow或者flex-basis）：1;10em/30px/auto/content/10% 双值（flex-grow|flex-basis或者flex-shink）:1 30px;1 1 三值（flex-grow|flex-shink|flex-basis）：1 1 10% 设置单个子容器如何沿纵轴排列： align-self: flex-start flex-end center baseline stretch 设置在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度: flex-basis: 设置子容器弹性伸展的比例,把剩余空间按比列分配给子元素： flex-grow:1 flex-grow:2 //前面一个占1后面一个占2 设置子容器弹性伸展的比例,超出部分按比列从子容器中减去： flex-shrink:1 flex-shrink:2 //前面一个减去超出部分的1，后面一个减去超出部分的2 设置排列顺序： order: //默认值为 0，可以为负值，数值越小排列越靠前。 一、水平居中文本/行内元素/行内块级元素水平居中.parent{ text-align: center; } 单个块级元素水平居中.son{ width: 100px; /*必须定宽*/ margin: 0 auto; } 多个块级元素水平居中.parent{ text-align: center; } .son{ display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/ } 利用绝对定位水平居中.parent{ height: 200px; width: 200px; /*定宽*/ position: relative; /*父相*/ background-color: #f00; } .son{ position: absolute; /*子绝*/ left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00; } 任意个元素，利用flex水平居中.parent{ display: flex; justify-content: center; } 二、垂直居中单行文本/行内元素/行内块级元素 垂直居中.parent{ height: 150px; line-height: 150px; /*与height等值*/ } 多行文本/行内元素/行内块级元素 垂直居中.parent{ /*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/ height: 150px; line-height: 30px; /*元素在页面呈现为5行,则line-height的值为height/5*/ } 图片垂直居中.parent{ height: 150px; line-height: 150px; font-size: 0; } .son-img{vertical-align: middle;} /*默认是基线对齐，改为middle*/ 单个块级元素 垂直居中使用table-cell实现： .parent{ display: table-cell; vertical-align: middle; } 使用绝对定位实现: 原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的*/ .parent{ height: 150px; position: relative; /*父相*/ } .son{ position: absolute; /*子绝*/ top: 50%; /*父元素高度一半,这里等同于top:75px;*/ transform: translateY(-50%); /*自身高度一半,这里等同于margin-top:-25px;*/ height: 50px; } /*优缺点 优点：使用margin-top兼容性好；不管是块级还是行内元素都可以实现 缺点：代码较多；脱离文档流；使用margin-top需要知道高度值；使用transform兼容性不好（ie9+）*/ 或 /*原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分*/ .parent{position: relative;} .son{ position: absolute; margin: auto 0; top: 0; bottom: 0; height: 50px; } /*优缺点 优点：简单;兼容性较好(ie8+) 缺点：脱离文档流*/ 使用flex实现： .parent{ display: flex; align-items: center; } 或 .parent{display: flex;} .son{align-self: center;} 或 /*原理：这个尚未搞清楚，应该是flex使margin上下边界无限延伸至剩余空间并平分了*/ .parent{display: flex;} .son{margin: auto 0;} 任意个元素利用flex实现.parent{ display: flex; align-items: center; } 或 .parent{ display: flex; } .son{ align-self: center; } 或 .parent{ display: flex; flex-direction: column; justify-content: center; } 三、水平垂直居中行内/行内块级/图片 水平垂直居中.parent{ height: 150px; line-height: 150px; /*行高的值与height相等*/ text-align: center; font-size: 0; /*消除幽灵空白节点的bug*/ } .son{ /*display: inline-block;*/ /*如果是块级元素需改为行内或行内块级才生效*/ vertical-align: middle; } 利用table-cell实现 水平垂直居中.parent{ height: 150px; width: 200px; display: table-cell; vertical-align: middle; /*text-align: center;*/ /*如果是行内元素就添加这个*/ } .son{ /*margin: 0 auto;*/ /*如果是块级元素就添加这个*/ width: 100px; height: 50px; } 利用button作为父元素 实现 水平垂直居中.parent-button{ /*改掉button默认样式就好了,不需要居中处理*/ height: 150px; width: 200px; outline: none; border: none; } .son{ display: inline-block; /*button自带text-align: center,改为行内水平居中生效*/ } 绝对定位水平垂直居中.parent{ position: relative; } .son{ position: absolute; top: 50%; left: 50%; /*定宽高时等同于margin-left:负自身宽度一半;margin-top:负自身高度一半;*/ transform: translate(-50%,-50%); } 或 .parent{ position: relative; } .son{ position: absolute; margin: auto; width: 100px; height: 50px; top: 0; bottom: 0; left: 0; right: 0; } flex 水平垂直居中.parent{ display: flex; } .son{ margin: auto; } 或 .parent{ display: flex; justify-content: center; align-items: center; } 或 .parent{ display: flex; justify-content: center; } .son{ align-self: center; } 视窗水平垂直居中原理：vh为视口单位，视口即文档可视的部分，50vh就是视口高度的50/100，设置50vh上边距 .son{ /*0如果去掉，则会多出滚动条并且上下都是50vh的margin。如果去掉就给body加上overflow:hidden;*/ margin: 50vh auto 0; transform: translateY(-50%); } 四、两列布局左列定宽，右列自适应1.利用float+margin实现 .left { background-color: #f00; float: left; width: 100px; height: 500px; } .right { background-color: #0f0; height: 500px; margin-left: 100px; /*大于等于#left的宽度*/ } 2.利用float+overflow实现 .left { background-color: #f00; float: left; width: 100px; height: 500px; } .right { background-color: #0f0; height: 500px; overflow: hidden; /*触发bfc达到自适应*/ } 3.利用table实现 .parent{ width: 100%; display: table; height: 500px; } .left { width: 100px; background-color: #f00; } .right { background-color: #0f0; } .left,#right{ display: table-cell; /*利用单元格自动分配宽度*/ } 4.利用绝对定位实现 .parent{ position:relative; } .left { position:absolute; background-color: #f00; width: 100px; height: 500px; } .right { position:absolute; left:100px; right:0px; background-color: #0f0; height: 500px; } 5.利用flex实现 .parent{ display:flex; } .left { background-color: #f00; width: 100px; height: 500px; } .right { flex:1; background-color: #0f0; height: 500px; } 6.利用grid（网格）实现 .parent{ display:grid; grid-template-columns:100px auto; } .left { background-color: #f00; } .right { background-color: #0f0; } 左列自适应，右列定宽1.利用float+margin实现 .parent{ padding-left:100px;//为了抵消margin-left:-100px } .left { width:100%; float:left; margin-left:-100px; background-color: #f00; } .right { width:100px; float:right; background-color: #0f0; } 2.利用float+overflow实现 //这里左右列的标签要换一下 &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;right&quot;&gt;右列定宽&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左列自适应&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; .left { overflow: hidden; /*触发bfc*/ background-color: #f00; } .right { float: right; width: 100px; background-color: #0f0; } 3.利用table实现 .parent{ display:table; width:100%; } .left { display:table-cell; background-color: #ff0; } .right { display:table-cell; width: 100px; background-color: #0f0; } 4.利用绝对定位实现 .parent{ position:relative; } .left { position:absolute; right:100px; left:0px; background-color: #ff0; } .right { position:absolute; right:0px; width: 100px; background-color: #0f0; } 5.利用flex实现 .parent{ display:flex; } .left { flex:1; background-color: #f00; } .right { width: 100px; background-color: #0f0; } 6.利用grid实现 .parent{ display:grid; grid-template-columns:auto 100px; } .left { background-color: #ff0; } .right { background-color: #0f0; } 左列不定宽，右列自适应1.利用float+overflow实现 .left { float:left; background-color: #f00; } .right { overflow:hidden; background-color: #0f0; } 2.利用flex实现 .parent{ display:flex; } .left { background-color: #ff0; } .right { flex:1; background-color: #0f0; } 3.利用grid实现 .parent{ display:grid; grid-template-columns:auto 1fr; } .left { background-color: #f00; } .right { flex:1; background-color: #0f0; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2018%2F08%2F28%2FES6%2F</url>
    <content type="text"><![CDATA[函数总体规则 不在函数内定义的变量具有全局作用域，所有的全局作用域变量被绑定到window的一个属性 内部函数变量可以访问外部函数变量 如果内部函数变量和外部函数变量名相同，内部函数变量会屏蔽外部函数变量 let块级作用域变量用var声明的变量作用于函数内部： function foo() { for (var i=0; i&lt;100; i++) { } i += 100; // 仍然可以引用变量i } 用let声明的变量： function foo() { var sum = 0; for (let i=0; i&lt;100; i++) { sum += i; } // SyntaxError:这里会报错 i += 1; } 注：const是具有块级作用域的常量，通常大写表示 解构赋值对多个变量进行赋值： var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;]; 多个变量嵌套赋值： let [x, [y, z]] = [&apos;hello&apos;, [&apos;JavaScript&apos;, &apos;ES6&apos;]]; 取一个对象中的若干数据赋值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos; }; var {name, age, passport} = person;//这里name,age,passport会分别被赋值对应属性 取一个对象中的数据，进行嵌套赋值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;, address: { city: &apos;Beijing&apos;, street: &apos;No.1 Road&apos;, zipcode: &apos;100001&apos; } }; var {name, address: {city, zip}} = person;//city,zip被赋值 //注意：这里的address不是变量，而是为了获得里面的数据对象的属性，直接访问会报not defined错误 如果变量对应的属性不存在，变量将被赋值为undefined。如果要使用变量名和属性名不一样，可以使用下面的语句： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos; }; // 把passport属性赋值给变量id: let {name, passport:id} = person;//id=&apos;G-123456&apos; //注意这里的passport也不是变量，和address类似。 解构赋值使用默认值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos; }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; Array的相关高阶函数map()方法定义在JavaScript的Array中，用来对Array中的每个元素进行相同的操作，比如对Array中的每个元素进行求平方： function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] console.log(results); reduce（）方法也是定义在JavaScript的Array中，reduce()把结果继续和序列的下一个元素做累计计算，比如对Array中的数组求和： var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 filter()函数用于把Array的某些元素过滤掉，然后返回剩下的元素。比如删掉Array中的偶数，只保留奇数: var arr = [1, 2, 4, 5, 6, 9, 10, 15]; var r = arr.filter(function (x) { return x % 2 !== 0; }); r; // [1, 5, 9, 15] sort()函数用于排序。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1 //注意：sort()方法默认把所有元素先转换为String，然后在根据字符的ASCII码进行排序 sort()可以接受一个比较函数来实现自定义排序，比如对一个数组按数字大小排序： var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { if (x &lt; y) { return -1; } if (x &gt; y) { return 1; } return 0; }); console.log(arr); // [1, 2, 10, 20] generator（生成器）generator生成器是ES6标准引入的新的数据类型。由function*定义，并且，除了return语句，还可以用yield返回多次。 比如利用generator函数生成一个斐波那契数列，它由0，1开头：0 1 1 2 3 5 8 13 21 34 … function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return; } 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法 var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} 第二个方法是直接用for … of循环迭代generator对象，这种方式不需要我们自己判断done： for (var x of fib(5)) { console.log(x); // 依次输出0, 1, 1, 2, 3, ... } 面向对象编程class继承1.子类必须在constructor方法中调用super方法 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class Student1 { constructor(name) { this.name = name; } hello() { alert(&apos;Hello, &apos; + this.name); } } class PrimaryStudent1 extends Student1 { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert(&apos;I am at grade &apos; + this.grade); } } var myStudent = new PrimaryStudent1(&apos;this is name1&apos;,&apos;this is grade1&apos;) myStudent.hello();// hello,this is name1 myStudent.myGrade();//I am at grade this is grade1 Promise在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。 一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败： function test(resolve, reject) { var timeOut = Math.random() * 2; log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;); setTimeout(function () { if (timeOut &lt; 1) { log(&apos;call resolve()...&apos;); resolve(&apos;200 OK&apos;); } else { log(&apos;call reject()...&apos;); reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;); } }, timeOut * 1000); } new Promise(test).then(function (result) { console.log(&apos;成功：&apos; + result); }).catch(function (reason) { console.log(&apos;失败：&apos; + reason); }); Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写： job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是Promise对象。 resolve 表示异步操作执行成功后的回调函数，reject 表示异步操作执行失败后的回调函数。 then接收resovle传递的数据，catch接收reject传递的数据。 next( 1 ).then( function( res ){ console.log( &apos;resolve:&apos; +res ); } ).catch( function( res ){ console.log( &apos;reject:&apos; + res ); } ); 字符串ES6模板语法连接字符串: var name = &apos;小明&apos;; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; alert(message); 获取字符串的长度： var s = &apos;Hello, world!&apos;; s.length; // 13 获取字符串某个指定位置字符, .charAt()方法有相同的功能： var s = &apos;Hello, world!&apos;; s[0]; // &apos;H&apos; s[6]; // &apos; &apos; s[7]; // &apos;w&apos; s[12]; // &apos;!&apos; s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined //注意：空字符也占一个位置。同时字符串是不可变的，如果对字符串某个索引赋值，不会有任何效果。 字符串方法：调用这些方法本身不会改变原有字符串的内容，而是返回一个新的字符串charAt()返回指定位置的字符 charCodeAt()返回指定位置的字符的Unicode编码 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf()搜索指定字符串出现的位置： var s = &apos;hello, world&apos;; s.indexOf(&apos;world&apos;); // 返回7 s.indexOf(&apos;World&apos;); // 没有找到指定的子串 lastIndexOf()返回字符串最后出现的位置 substring()返回指定索引区间的子串： var s = &apos;hello, world&apos; s.substring(0, 5); // **从索引0开始到5（不包括5）**，返回&apos;hello&apos; s.substring(7); // 从索引7开始到结束，返回&apos;world&apos; split(separator,howmany)按分隔符分割字符串数组，第一个参数必需，分割符，第二个参数可选，表示返回新字符串数组的最大长度： var str=&apos;How are you?&apos; str.split(&apos; &apos;) //How,are,you? str.split(&apos;&apos;) //H,o,w, ,a,r,e, ,y,o,u,? str.split(&apos; &apos;,2) //How,are trim()去掉字符串首尾的空格 var greeting = &apos; Hello world! &apos;; console.log(greeting.trim()); // expected output: &quot;Hello world!&quot;; 数组方法indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;]; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;] arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] // 只删除,不添加: arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;] arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;] // 只添加,不删除: arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素 arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] //如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： push()和pop() push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： var arr = [1, 2]; arr.push(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4 arr; // [1, 2, &apos;A&apos;, &apos;B&apos;] arr.pop(); // pop()返回&apos;B&apos; arr; // [1, 2, &apos;A&apos;] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] unshift()和shift() 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： var arr = [1, 2]; arr.unshift(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4 arr; // [&apos;A&apos;, &apos;B&apos;, 1, 2] arr.shift(); // &apos;A&apos; arr; // [&apos;B&apos;, 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] sort()sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： var arr = [&apos;B&apos;, &apos;C&apos;, &apos;A&apos;]; arr.sort(); arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] reversereverse()把整个Array的元素给掉个个，也就是反转： var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]; arr.reverse(); arr; // [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; var added = arr.concat([1, 2, 3]); added; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3] arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] //注意concat()方法并没有修改当前Array，而是返回了一个新的Array。 joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3]; arr.join(&apos;-&apos;); // &apos;A-B-C-1-2-3&apos; includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 var array1 = [1, 2, 3]; console.log(array1.includes(2)); // expected output: true MapMap是一组键值对的结构，具有极快的查找速度。 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 循环for…infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来： var o = { name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos; }; for (var key in o) { console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos; } for…of循环是ES6引入的新的语法: var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]); var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]); for (var x of a) { // 遍历Array console.log(x); } for (var x of s) { // 遍历Set console.log(x); } for (var x of m) { // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]); } forEach更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + &apos;, index = &apos; + index); }); 浏览器对象windowwindows对象不但充当全局作用域，而且表示浏览器窗口。 window.innerWidth浏览器窗口内部宽度，window.outerwidth浏览器窗口整个宽度。window.innerHeight浏览器窗口内部高度，window.outerHeight浏览器窗口整个高度//外部是浏览器窗口整个的大小，内部窗口是页面能显示的窗口大小。 navigatornavigator对象表示浏览器的信息。 navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 screenscrenn对象表示屏幕的信息。 screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。//如果你的windows把屏幕放大为125%，那么1920x1080的屏幕会显示为1536x864。 locationlocation对象表示当前页面的URL信息。例如，一个完整的URL： http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： location.protocol; // &apos;http&apos; location.host; // &apos;www.example.com&apos; location.port; // &apos;8080&apos; location.pathname; // &apos;/path/index.html&apos; location.search; // &apos;?a=1&amp;b=2&apos; location.hash; // &apos;TOP&apos; location.origin //http://www.example.com location.href// http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，可以调用location.reload()。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
