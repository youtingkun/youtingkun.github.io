<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在表格的自定义列里面实现自定义验证]]></title>
    <url>%2F2019%2F06%2F21%2F%E5%9C%A8%E8%A1%A8%E6%A0%BC%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E9%87%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[实现方法 简单来说就是先在el-table外面套一个el-form。 然后再在表格的模板template里面包含el-form-item。 在绑定prop的时候要注意绑定的是每一个item的prop 1234567891011121314151617&lt;el-form ref=&quot;ruleForm&quot; :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; :inline-message=&quot;true&quot;&gt; &lt;el-table :data=&quot;ruleForm.purchaseList&quot;&gt; &lt;el-table-column label=&quot;数量&quot; prop=&quot;goodsNumber&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-form-item :prop=&quot;`purchaseList.$&#123;scope.$index&#125;.goodsNumber`&quot; :rules=&quot;rules.test&quot;&gt; &lt;el-input size=&quot;mini&quot; type=&quot;number&quot; v-model=&quot;scope.row.goodsNumber&quot; placeholder=&quot;请输入数量&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/el-form&gt; 123456ruleForm: &#123; purchaseList: []&#125;,rules: &#123; test: [&#123; required: true, message: &quot;请输入&quot;, trigger: &quot;change&quot; &#125;]&#125; 123456789submitStep() &#123; this.$refs.ruleForm.validate(valid =&gt; &#123; if (valid) &#123; alert(&quot;submit!&quot;); &#125; else &#123; console.log(&quot;error submit!!&quot;); return false; &#125;&#125;)]]></content>
      <categories>
        <category>Element UI</category>
      </categories>
      <tags>
        <tag>Element表格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prototype和_proto_]]></title>
    <url>%2F2019%2F06%2F21%2Fprototype%E5%92%8C_proto_%2F</url>
    <content type="text"><![CDATA[为什么会产生prototype和proto由于JavaScript中没有类的概念，所有的数据类型都是object。类的一个重要的功能就是实现继承，所以才会产生出了prototype和proto来模仿类的功能。 Function和ObjectFunction 和 Object 的区别: Function 可以被执行,Prototype是函数独有的属性 Function 可以当做 Object 的构造函数，比如当我们使用 new操作符后面跟着一个 Function时，这个 Function会被当成构造函数返回一个对象。所以说函数也是对象的一个构造函数。 构造函数function有prototype属性，而示例object没有prototype属性。比如下面的函数： 123456function Parent(name)&#123; this.name = name;&#125;let P = new Parent("张三")console.log(Parent.prototype) //Parent&#123;&#125;console.log(p.protoyepe) //undefined 在继承中prototype和proto起到了什么作用 proto和prototype 不同，prototype 只在 Function 中有，而proto则在Function和Object中都有。 12345678function Parent(name)&#123; this.name = name;&#125;let P = new Parent("张三")console.log(Parent.prototype) //Parent&#123;&#125;console.log(p.protoyepe) //undefinedconsole.log(Parent._proto_) //[Function]console.log(p._proto_) //Parent&#123;&#125; 简单总结javascript继承的本质： ==一个对象 A的proto属性指向的那个对象B，B就是 A 的原型对象（或者叫父对象），对象 A 可以使用对象 B 中的属性和方法，同时也可以使用对象 B 的 原型对象C 上的属性和方法，以此递归，就是所谓的原型链== 12345678910let A = &#123;name:'a'&#125;let B = &#123;age:'18'&#125;let C = &#123;hobby:'敲代码'&#125;A._proto_ = B;B._proto_ = C;console.log(A.name) //aconsole.log(A._proto_.age)//18console.log(A._proto_._proto_.hobby)//敲代码 new 操作到底做了什么通过上面的分析，我们知道 p 是 object 的类型，Parent 是 Function 类型。在 java中，如果你这么写，那么 Parent 应该是一个类（class），但是 javascript 中并没有类，但是我们又很想借鉴这种语法形式，应该怎么办呢，这个任务只能交给 Function。看下完整代码： 12345678910111213function Parent(name,age,hobby)&#123; this.name = name; this.age = age; this.hobby = hobby;&#125;Parent.prototype.getName = function()&#123; return this.name&#125;let P = new Parent("张三",18,"敲代码")console.log(P.name) //张三console.log(P.age) //18console.log(P.hobby) //敲代码P._proto_ === Parent.prototype //true 第一步：Parent 被执行。当使用 new关键字时，Parent 函数会在 p 的作用域下被执行，所以这里的 this 就是实例p，这样，name,age,hobby三个属性才会被当做 p 的属性被创建， 第二步：将 p.proto指向 Parent.prototype,这才是构造函数的精髓所在，所以，p 就继承了 Parent.prototype中的（以及其原型链上的）属性和方法。 最后总结一下: proto是真正用来查找原型链去获取方法的对象。prototype是在用new创建对象时用来构建proto的对象 prototype是function独有的,proto是function和object都有的 prototype指的是函数本身,proto指的是这个对象所链接到的父对象]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS宏任务与微任务]]></title>
    <url>%2F2019%2F06%2F21%2FJS%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[宏任务与微任务同步任务和异步任务首先js是单线程，任务需要一个一个的执行。但是如果一个任务耗时过长，就会让后面的任务等待。为了解决这个问题，程序员将任务分为两大类：同步任务和异步任务。 简单解释下这张图的逻辑: 同步任务会进入主线程，异步任务会进入Event Table并注册函数。 当指定事情完成时，Event Table会将函数移入Event Queue。 主线程的任务执行完毕为空时，会去Event Queue读取函数进入主线程执行。 不断重复上述过程，Event Loop(事件循环) js引擎存在monitoring process进程，会持续不断的检查主线程是否为空。 微任务和宏任务宏任务和微任务都是异步任务，主要区别是他们的执行顺序。 简单解释下这张图的逻辑: 首先宏任务和微任务都会被当成异步任务被执行。 判断是否有微任务执行，执行微任务。如果没有，执行宏任务。 在执行宏任务的时候，可能会生成多个微任务，这个宏任务执行完了之后会执行它所产生的微任务。 执行下一个宏任务。 宏任务包括：整体代码script,setTimeout,setInterval,setLmmediate。微任务包括：Promise,process.nextTick,MutationObserver。 123456789101112// process是Node.js中的进程setTimeout(()=&gt;&#123; console.log('setTimeout1')&#125;,0)let p = new Promise((resolve,reject)=&gt;&#123; console.log('Promise1') resolve()&#125;)p.then(()=&gt;&#123; console.log('Promise2') &#125;)// 输出Promise1,Promise2,setTimeout1 因为Promise是微任务，当同步任务Promise1行完了以后会，会去Event Queue中执行微任务Promise2，然后执行宏任务setTimeout1。 setInterval: setInterval和setTimeout类似，不过前者不是设置多少毫秒之后执行，setInterval(fn,ms)是每隔指定时间将函数注入Event Queue中，如果前面的任务耗时太久，那么同样需要等待。 值得注意的是，一旦setInterval的回调函数fn执行时间超过了延迟时间ms,那么就完全看不出来时间间隔。 process.nextTick: process.nextTick(callback)相当于node.js版的setTimeout，在时间循环的下一次循环中间调用callback回调函数。 一个比较综合的例子： 1234567891011121314151617181920212223242526272829303132333435console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;)//最后输出的顺序是1,7,6,8,2,4,3,5,9,11,10,12 这里的关键在于普通同步任务第一次执行完了以后，会先执行异步任务里面的微任务，然后才开始宏任务微任务循环 总结一下异步执行的顺序： 首先分析有多少个宏任务 每个宏任务中，分析有多少个微任务 根据调用的次序，确定宏任务中微任务的执行顺序，如果执行微任务的时候产生了新的微任务，会执行完这个新的微任务再执行下一个宏任务。 根据宏任务的触发规则和调用次序，确定宏任务的执行次序 确定整个顺序]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue实例生命周期、vue父子组件生命周期、router生命周期、vuex生命周期的区别和联系]]></title>
    <url>%2F2019%2F05%2F15%2Fvue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81router%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81vuex%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[销毁和创建组件的生命周期： 1.通过v-if来控制组件的销毁和重建 刷新当前页面： 1.直接刷新整个页面 location.reload() this.$router.go(0) //这两种都可以刷新当前页面，缺点就相当于按ctrl+F5强制刷新页面，会出现一个瞬间的空白页面。 2.新建一个空白页面supplierAllBack.vue，点击确定的时候先跳转到这个空白页，然后再跳转回来。 3.使用provide/inject组合方式。 在App.vue中 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;App&apos;, provide () { return { reload: this.reload } }, data () { return { isRouterAlive: true } }, methods: { reload () { this.isRouterAlive = false this.$nextTick(function () { this.isRouterAlive = true }) } } } &lt;/script&gt; 在页面中： inject:[&quot;reload&quot;] this.reload() vue实例生命周期beforeCreate: 1234data中数据生成computed中数据生成watch中数据生成methods中数据生成 created: 此时就可以访问到data、computed、watch、methods中的方法和数据 beforeMount: mounted: beforeUpdate: updated: beforeDestroy: destoryed: 父子组件生命周期父组件： beforeCreate: created: beforeMount: 子组件： beforeCreate: created: beforeMount: mounted: mounted: beforeUpdate: 子组件： beforeUpdate: updated: updated: beforeDestroy: 子组件： beforeDestroy: destoryed: destoryed: vue-router生命周期一、全局路由：beforeEach: beforeResolve: afterEach: 二、路由独享守卫beforeEnter: 三、组件内beforeRouterEnter: beforeRouteUpdate: beforeRouteLeave: 四、完整的导航解析流程123456789101112- 导航被触发。- 在失活的组件里调用离开守卫。- 调用全局的 beforeEach 守卫。- 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。- 在路由配置里调用 beforeEnter。- 解析异步路由组件。- 在被激活的组件里调用 beforeRouteEnter。- 调用全局的 beforeResolve 守卫 (2.5+)。- 导航被确认。- 调用全局的 afterEach 钩子。- 触发 DOM 更新。- 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 vuex生命周期vuex中的变量和方法本质上是属于全局的变量和方法。所以在页面刷新时才会消失，其它时间都是在更改。 vue实例与vue-router的生命周期进入路由： beforeEach: 组件： beforeRouteUpdate: 路由配置： beforeEnter： 组件： beforeRouterEnter: beforeResolve: afterEach: 组件： beforeCreate: created: beforeMount: mounted: beforeUpdate: updated: 离开组件： beforeRouteLeave: 路由： beforeEach: afterEach: 组件： beforeDestroy: destoryed: vue实例与vuex的生命周期因为vuex中的数据声明在computed中，方法声明中methods中，所以vuex中数据和方法的使用，跟随着vue实例中computed和methods的生命周期。 数据和方法初始化beforeCreate: computed中数据生成： state和getter中的数据 methods中方法生成： action和mutaion中的方法 created: beforeMount: mounted: beforeUpdate: updated: beforeDestroy: destoryed: 数据更新：vuex： actions: mutations: 组件： beforeUpdate: updated:]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue插槽与父子组件传值]]></title>
    <url>%2F2019%2F03%2F06%2Fvue%E6%8F%92%E6%A7%BD%E4%B8%8E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1.父子组件之间的传值子组件传值到父组件子组件在向父组件传值的时候，主要是通过子组件通过$emit()函数派发出事件，然后再父组件中通过事件监听: //比如定义了一个子组件&lt;i-button&gt; &lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { handleClick () { this.$emit(&apos;on-click&apos;, {a:123}); } } } &lt;/script&gt; //这里的on-click是事件的名字，a是要传递的参数 //然后在父组件中监听 &lt;i-button @on-click=&quot;sayhi&quot;&gt;sayhi&lt;/i-button&gt; &lt;script&gt; export default { methods:{ sayhi(b){ console.log(b); // Vue.js } } } &lt;/script&gt; //注意这里的b只是用来接收子组件传递过来的对象，输入的是{a:123},并不会输出123,如果输出123可以写成b.a 父组件向子组件传值父组件向子组件传值，主要是通过子组件的prop属性来接收父组件的数据: //比如在父组件中声明传值 &lt;i-button :title=titleData&gt;&lt;/i-button&gt; data(){ return{ titleData:&apos;hello props&apos; } }, //在子组件&lt;i-button&gt;中接收 &lt;h3&gt;{{title}}&lt;/h3&gt; props: [&quot;title&quot;], //这里就会显示为&lt;h3&gt;helo props&lt;/h3&gt; 或者使用props中声明的为对象的方式: //在父组件中声明传值 &lt;i-button :title=titleData&gt;&lt;/i-button&gt; data(){ return{ titleData:&apos;hello props&apos; } }, //在子组件&lt;i-button&gt;中接收 &lt;h3&gt;{{title}}&lt;/h3&gt; props: { title:{ }, }, //这里也会显示为&lt;h3&gt;helo props&lt;/h3&gt; 2.插槽传值，插槽的定义是子组件显示什么内容由父组件决定插槽传值的基本用法：比如定义了一个子组件&lt;i-button&gt; &lt;template&gt; &lt;button&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/button&gt; &lt;/template&gt; 在父组件中使用 &lt;i-button&gt;按钮1&lt;i-button&gt; 这里就会显示成为 &lt;button&gt;按钮1&lt;button&gt; 给插槽起个名字：//子组件 &lt;template&gt; &lt;button&gt; &lt;slot name=&quot;icon&quot;&gt;&lt;/slot&gt; &lt;slot&gt;solot里面默认的内容&lt;/slot&gt; &lt;/button&gt; &lt;/template&gt; //父组件 &lt;i-button slot=&quot;icon&quot;&gt;按钮1&lt;/i-button&gt; &lt;i-button &gt;按钮2&lt;/i-button&gt; &lt;i-button &gt;&lt;/i-button&gt; //这里解释一下 1.如果在父组件中使用的时候给slot赋值了名字，那么这里子组件就会显示&lt;button&gt;按钮1&lt;/button&gt; 2.如果在父组件中没有赋值名字，但给了子组件要显示的内容，那么这里子组件就会显示&lt;button&gt;按钮2&lt;/button&gt; 3.如果在父组件中没有赋值名字，也没有给了子组件要显示的内容，那么这里子组件就会显示默认的内容&lt;button&gt;solot里面默认的内容&lt;/button&gt; 作用域插槽：如果我们在父组件中这样写： &lt;i-button &gt;{{titleData}}&lt;/i-button&gt; 这里的titleData是父组件中的数据，这样写是不能够正常工作的，因为titleData是父组件的数据，子组件并不能获取到，这个时候就需要用到我们的作用域插槽了。 父组件来访问子组件的数据： //父组件 &lt;i-button &gt; &lt;template slot-scope=&quot;parentName&quot;&gt;{{parentName.childrenName}}&lt;/template&gt; &lt;/i-button&gt; //子组件&lt;i-button&gt; &lt;template&gt; &lt;button&gt; &lt;slot :childrenName=&quot;childrenData&quot;&gt;&lt;/slot&gt; &lt;/button&gt; &lt;/template&gt; data(){ return{ childrenData:&quot;hello slot-scope&quot; } }, //这里父组件就会拿到子组件childrenData的值，显示为&lt;button&gt;hello slot-scope&lt;/button&gt; //解释下，parentName可以理解是父组件与子组件之间的标识，childrenName才是真正绑定的数据 如果我们从父组件中传值过去到子组件中显示，就需要利用父子组件之间传值的方法了： //父组件 &lt;i-button :parenDataName=&quot;parentData&quot;&gt; &lt;template slot-scope=&quot;parentName&quot;&gt;{{parentName.childrenName}}&lt;/template&gt; &lt;/i-button&gt; data(){ return{ parentData:&quot;hello slot-scope parent&quot; } }, //子组件&lt;i-button&gt; &lt;template&gt; &lt;button&gt; &lt;slot :childrenName=&quot;childrenData&quot;&gt;&lt;/slot&gt; &lt;/button&gt; &lt;button&gt; &lt;slot :childrenName=&quot;parentDataName&quot;&gt;&lt;/slot&gt; &lt;/button&gt; &lt;/template&gt; props: { parentDataName:{} }, data(){ return{ childrenData:&quot;hello slot-scope children&quot; } }, //这里一个是直接访问子组件中的值，一个是先自己传递过去之后再访问子组件中的值 区别现在我们已经知道了插槽与父子组件之间传值的基本用法，那么他们之间有什么区别呢？我概况为以下几点 1.插槽之间的传值，插槽要显示的内容是写在父组件中的，也就是父组件中的数据是写在自己的组件里。 2.而父子组件之间的传值，是在当前组件拿到了数据之后，然后才在当自己的组件中显示。 3.如果说他们之间有什么联系的话，插槽传值，其实类似于父组件向子组件传值。而插槽默认值的写法又像是子组件向父组件传值，只是如果父组件有传值过来，会被覆盖掉了而已。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let和var不得不说的关系]]></title>
    <url>%2F2018%2F12%2F08%2Flet%E5%92%8Cvar%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[let：声明的let变量只作于于代码块内部，外部访问会报变量没有被定义的错误。 而var变量在没有声明时访问，只会返回undefined，并不会报错。 什么叫代码块内部昵？简单来说就是被{}所包裹的内容。 当在（）中声明的let变量，也只能在它后面的{}中访问。即{}可以看做let作用域的子作用域。 var a = 1; { var b = 2; let c = 3; } 或 for (var b1 = 1 ; b1&lt;=3;b1++) { console.log(b1) } for (let c1 = 1; c1 &lt;= 3; c1++) { console.log(c1) } //这里的a、b、b1都能在外部访问。而c、c1只能在内部访问。 变量提升：当声明的var变量，变量会自动提升为全局变量。不管是在函数外部还是在函数内部，只要在定义之后都可以访问。 for (var b1 = 1 ; b1&lt;=3;b1++) { console.log(b1); console.log(b2); for (var b2 =1; b2 &lt;=3; b2++) { console.log(b1); console.log(b2) } console.log(&quot;------------------------------------&quot;) } console.log(b1) console.log(b2) //这里都能访问b1,b2。只是在内部第一层第一次访问b2时会返回undifined。 对应的用let声明： for (let c1 = 1; c1 &lt;= 3; c1++) { console.log(c1) for (let c2=1; c2&lt;=3; c2++) { console.log(c1) console.log(c2) } console.log(&quot;------------------------------------&quot;) } //这里内部第二层可以访问到c1,也就是说这里的作用域包括了它的子作用域。 var变量名相同时： 同层： var a =1 var a =2 //a=2，即他们共享内存地址。 不同层： for (var b1 = 1 ; b1&lt;=3;b1++) { console.log(b1); console.log(b1); for (var b1 =1; b1 &lt;=3; b1++) { console.log(b1); console.log(b1) } console.log(&quot;------------------------------------&quot;) } console.log(b1) console.log(b1) //第一层b1和第二层b2共享内存地址。 //这里外部循环只会执行一次，即内部循环跳出时，外部的第二次循环b2的值已经是4。 //由于for循环特性，依然会执行b++，所以最后输出的b1的值为5 let变量名相同时： 同层： let a =1 let a =2 console.log(a) //会报错，提示&apos;a&apos;has already been declared 不同层： for (let c1 = 1; c1 &lt;= 3; c1++) { console.log(c1) for (let c1=1; c1&lt;=3; c1++) { console.log(c1) console.log(c1) } console.log(&quot;------------------------------------&quot;) } // //第一层c1和第二层c1有单独的内存地址。 //这里第一层和第二层的c1名字虽然是一样的，但是在自己的块内只访问自己的变量。 //即第一层只访问第一层的变量，第二层访问第二层的变量。相互之间不影响。 var变量于let变量同名时： 同层： var b =1 let b =7 console.log(b) //会报错，&apos;b&apos; has already been declared let b =1 var b=7 //会报错，&apos;b&apos; has already been declared for (let b1 = 1; b1 &lt;= 3; b1++) { var b1 = 7; console.log(b1) } //这样写也会报错 for (var b1 = 1; b1 &lt;= 3; b1++) { let b1 = 7; console.log(b1) } //按理来说，这样也应该叫同层，会报错。但是不会，会正常的输出三个7。 不同层： var b =1 for (let b=1;b&lt;=3;b++) { console.log(b) } console.log(b) //正常输出 let b =1 for (var b=1;b&lt;=3;b++) { console.log(b) } console.log(b) //会报错，&apos;b&apos; has already been declared for (var b1 = 1; b1 &lt;= 3; b1++) { let b1 = 7; console.log(b1) } console.log(b1) //正常输出 for (let b1 =1;b1&lt;=3;b1++) { var b1 = 7 console.log(b1) } //会报错，&apos;b&apos; has already been declared 综上述，可得出结论： 1. for（）里面的域可以看作是它外部域的子域，是它后面{}的父域。2. var可以设置同名变量，因为会自动提升为全局变量，共享内存地址。3. let同层不可以设置同名变量。4. var和let变量名相同时，不可以在同一层。5. var和let变量名相同时，var变量可以在let变量的外层，而let变量不能在var变量的外层。 const：const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了 const为常量时不可修改，声明时必须要初始化。 const a =1 a=2 //报错 const为对象或数组时： const a = [&quot;1&quot;,&quot;2&quot;] a.push(&quot;3&quot;) console.log(a) //可以对数组进行修改 function f() { console.log(&quot;1&quot;) } const a = f() function f(){ console.log(&quot;2&quot;) } //这里输出&quot;2&quot;，可以对函数对象修改 函数作用域：ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用： function f() { console.log(&quot;f0&quot;); function f(){ console.log(&quot;f01&quot;) } f() } f() //输出&quot;f0&quot; &quot;f01&quot; function f() { console.log(&quot;f0&quot;); function f1(){ console.log(&quot;f1&quot;) } f1() } f() f1()//到这里的时候报错，外部不能访问内部函数。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局大法好]]></title>
    <url>%2F2018%2F12%2F07%2Fflex%E5%B8%83%E5%B1%80%E5%A4%A7%E6%B3%95%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[flex布局相关概念： 存在两个轴： main axis 横轴（主轴）、 cross axis 纵轴（交叉轴）。 如果一个方向被设置成为了主轴，那么另外一个方向就为交叉轴。也就是说这两个轴是相对的。横轴可以是主轴也可以是交叉轴。纵轴可以是主轴也可以是交叉轴。 横轴的开始位置叫 main start，结束位置叫main end。纵轴的开始位置叫 cross start，结束位置叫 cross end。 元素内部的子元素，宽度叫main size，高度叫 cross size。 注意：当给父元素设置了宽高，而子元素没有设置宽高时：主轴方向的不会被子元素充满，而不是主轴的方向子元素会自动增加或缩减充满父元素。也就是说： 如果flex-direction：row时，子元素的高度会自动增加填满父元素的高度，而子元素的宽度不会自动增加。 如果flex-direction：column时，子元素的宽度会自动增加填满父元素的高度，而子元素的高度不会自动增加。 flex布局的父元素元素可以设置六种属性：flex-wrap flex-flow flex-direction justify-content align-item align-content flex-direction：设置内部元素排列的方向 row //从左到右 row-reverse //从右到左 column //从上到下 column //从下到上 flex-wrap：设置如果一行放不下，如何换行。如果flex-direction设置为column，那么这里的一行指的是一列 nowrap //默认，不换行。如果子元素宽度超过一行，那么元素的宽度会被压缩 wrap //在第一行下方 wrap-reverse //在第一行上方 flex-flow：flex-direction和flex-wrap的简写。 row nowrap //默认值 justify-content：设置子元素在主轴上的对齐方式。 flex-start //从主轴的开始进行对齐 flex-end //从主轴的结尾开始对齐 flex-center //处于主轴中间 //前面三个都不会自动改变元素的外边距，后面两个会。 space-between //除了两边的元素外，其它元素间距相等 sapce-around //每个元素的间距都相等 align-items： 设置在纵轴上如何对齐 //这一行的元素在这一行的高度所在的位置。如果有多行，每一行将会平分父元素的高度。 flex-start //从纵轴的开始进行对齐 flex-end //从纵轴的结尾开始对齐 center //处于纵轴的中间 baseline //以子元素中第一行文字的基线对齐 stretch//默认值，如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content设置了多根轴线的对齐方式。如果只有一根轴线，该属性不起作用。 和align-items的区别在于，aligni-items更偏向于一行，而align-content更偏向于多行。简单的来说，只有一行时，设置align-content会失效，而有多行时设置的align-items会被alig-content的设置覆盖掉。 flex-start //从交叉轴开始进行对齐 flex-end //从交叉轴结尾开始对齐 flex-center //处于交叉轴中间 space-between //除了上下的元素外，其它行间距相等。 sapce-around //每行的间距都相等 flex布局子元素可以设置的六个属性order flex-grow flex-shrink flex-basis flex align-self order：设置子元素的排列顺序，数值越小越靠前。默认为0，可以为负数 //1、2、3...相对数值 //如数值相同，会按照原来的相对位置排列 flex-grow：设置元素的放大比列，这里的放大比例是指，按剩余空间的大小进行放大。默认0，即不放大，不可以设置负数。 //1、2、3...为相对剩余空间放大比列 flex-shrink：设置元素的缩小比列。默认值为1，不可以设置负数。 //这里的缩小比例是指放不下时的缩小比列，如果设置了nowrap，那么此属性无效。 //设置的数字越大，空间不足时，缩小的比列越大。 flex-basis：设置在分配多余空间之前，项目占据主轴的空间大小。浏览器根据这个属性计算是否还有剩余空间。默认值为auto，即元素本身大小。 //如果同时设置了元素本身的宽高，又设置了flex-basis，计算的时候以flex-basis为准 flexflex-grow，flex-shrink和flexbasis的简写。 //默认值为 0，1，auto，后面两个参数可选。 align-self允许当前元素与其它项目有不一样的对齐方式，即覆盖掉父元素的align-items的值。 //默认为auto，即继承父元素的align-items的值。 //属性可以设置align-items中的属性。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css选择器]]></title>
    <url>%2F2018%2F11%2F26%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、简单选择器：1.标签选择器 2.类选择器 3.id选择器 4.通用选择器* 二、属性选择器：属性选择器是一种特殊类型的选择器，它根据元素的 属性 和属性值来匹配元素。它们的通用语法由方括号 ([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。属性选择器可以根据其匹配属性值的方式分为两类： 存在和值属性选择器和子串值属性选择器。 1.存在值选择器： 2.正则表达式选择器： 三、伪类和伪元素选择器：1.伪类： 一个 CSS 伪类（pseudo-class） 是一个以冒号(:)作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。 2.为元素： 伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (::) ， 同样是添加到选择器后面去选择某个元素的某个部分。 四、组合器和多用选择器：虽然一次使用一个选择器就很有用，但在某些情形中却可能效率低下。 CSS选择器在你开始组合他们进行细粒度选择的时候变得更具使用价值。基于元素之间的相互关联关系，CSS提供了几种方法来对元素进行选择。下表使用连接符展示了这些关联关系(A和B代表前文所述的任意选择器):]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookies、session、LocalStorage、SessionStorage的区别]]></title>
    <url>%2F2018%2F11%2F24%2FCookies%E3%80%81session%E3%80%81LocalStorage%E3%80%81SessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[cookie和session HTML4提供的缓存机制，都是用来跟踪浏览器用户身份的会话方式。 Local Storage和Session Storage HTML5提供的本地缓存机制，只能存储字符串类型。 sessionStorage：仅在当前浏览器窗口关闭前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存；cookie只在设置的cookie过期时间之前一直有效。 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 cookie：1.cookie保存在浏览器内存中，大小限制为4kb，随浏览器关闭而结束。如果设置了过期时间，会被保存在硬盘中，关闭浏览器后，数据仍然存在，知道过期时间结束才消失。 2.cookie应用于判断用户是否登陆过网站，以便下次登陆时能够自动登陆。 3.cookie安全信较低，每次访问都要传送cooki给服务器。 session：1.session保存在服务器端，没有大小限制，当服务器收到创建session对象请求时，如果客户端的请求包含sessionid，服务器返回sessionid对应的session对象。如果没有sessionid,服务器会创建sessionid和session对象返回给客户端。通常使用cookie方式存储sessionid到客户端。 2.session用于保存每个用户的专用信息，通过seeionID来区分不同的客户。比如用户的登陆信息，购物车信息等。 3.要先攻破cookie才能攻破session，如果存用户信息过多，会占用服务器内存。 Local Storage:1.永久保存在客户端的本地硬盘中。即使浏览器关闭了，下次访问该网站时仍能使用。 Session Storage:1.将数据保存在session对象中。生命周期为进入网站，直到浏览器窗口关闭的这段时间。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>网络缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络相关协议]]></title>
    <url>%2F2018%2F11%2F24%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[应用层：FTP（File Transfer Protocol）:可靠的文件传输协议。 TFTP（Trivial File Transfer Protocol）：不可靠的小文件传输协议。 HTTP（HyperText Transfer Protocol）：超文本传输协议。使用SSL加密后的安全网络协议为HTTPS。 SMTP（Simple Mail Transfer Protocol）和POP3（Post Office Protocol - Version 3）：邮件传输协议，邮件报文采用ASCII格式表示。 Telnet:远程连接协议。 SNMP（Simple Network Management Protocol）：简单网络管理协议，必须以管理员的身份登录才能完成配置。 DHCP（Dynamic Host Configuration Protocol）：动态分配IP地址协议，DHCP客户端能从DHCP服务器获得DHCP服务器的IP地址、DNS服务器的IP地址、默认网关的IP地址等。 DNS（Domain Name System）：将域名解析为IP地址。分为递归查询和迭代查询。 递归查询：主机提出一个查询请求，本地服务器会自动一层一层的查询下去，直到找到满足查询请求的IP地址，再返回给主机。即问一次，就得到最终结果。 迭代查询：服务器收到一次查询请求，就回答一次。但回答的不一定是最终地址，也可能是其他层次服务器的地址。然后客户端再去提交查询请求。即问一次答一次，而后再去问其他服务器，直到问道结果。 WEP（Wired Equivalent Privacy）：有线等价协议。两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。 传输层：TCP（Transmission Control Protocol）：可靠连接。 UDP（User Datagram Protocol）：不可靠连接。 网络层：IP（Internet Protocol）：最重要的核心协议，无连接、不可靠。 ICMP（Internet Control Message Protocol）：因特网控制信息协议，用来检测网络通信是否顺畅。 ARP（Address Resolution Protocol和RARP（Reverse Address Resolution Protocol）：地址解析协议。ARP是把IP地址解析为MAC物理地址，RARP是把MAC物理地址解析为IP地址。 IGMP（Internet Group Management Protocol）：网络组管理协议。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从URL到页面显示发生了什么]]></title>
    <url>%2F2018%2F11%2F22%2F%E4%BB%8EURL%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[一、在浏览器地址栏输入URL浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 二、进行DNS域名解析浏览器解析URL获取协议，主机，端口，PATH。把这些请求组装一个HTTP（GET）请求报文: //首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF //首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束 //请求头和消息实体之间有一个CRLF分隔 //根据实际请求需要可能包含一个消息实体 GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1 Host: www.w3.org Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 Referer: https://www.google.com.hk/ Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: authorstyle=yes If-None-Match: &quot;2cc8-3e3073913b100&quot; If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT name=qiu&amp;age=25 浏览器获取主机ip地址，解析的查找顺序依次为： 1.浏览器自身的DNS缓存 2.本机DNS缓存 //存放在内存中，关机就消失 3.hosts文件 //存放在系统文件夹中 4.路由器缓存 5.DNS域名服务器 6.根域名服务器。 DNS服务器的分级查询： 主机名.次级域名.顶级域名.根域名 = www.google.com.root //一般root会被省略，因为对于所有的域名都是一样的。全世界有13台根服务器，域名为a.root-servers.net 到m.root-servers.net。 所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下： 1.从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的NS记录和A记录（IP地址） 2.从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的NS记录和A记录（IP地址） 3.从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的IP地址 //NS记录（Name Server的缩写），即哪些服务器负责管理google.com的DNS记录。 根域名服务器分布： 查找方式分为两种： 迭代和递归。简单来说，迭代查询就是需要本地服务器自己去找，而递归查询是其它其它服务器直接把查询好的结果告诉它。 三、根据目标IP地址，端口建立TCP链接进行TCP协议三次握手： 1.主机向服务器发送一个建立连接的请求（您好，我想认识您）；2.服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；3.主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。//结束断开的时候为四次挥手 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z 四、服务器将响应报文，返回HTTP报文给浏览器服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 返回的HTTP报文如下： //首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF //首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束 //请求头和消息实体之间有一个CRLF分隔 //根据实际请求需要可能包含一个消息实体 一个请求报文例子如下： GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1 Host: www.w3.org Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 Referer: https://www.google.com.hk/ Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: authorstyle=yes If-None-Match: &quot;2cc8-3e3073913b100&quot; If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt; &lt;/html&gt; 五、浏览器解析渲染页面浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本： 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面）]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树相关]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[创建 function Node(data,left,right){ this.data = data;//数值 this.left = left;//左节点 this.right = right;//右节点 }; 插入二叉树 function insert(node,data){ //创建一个新的节点 let newNode = new Node(data,null,null); //判断是否存在根节点，没有将新节点存入 if(node == null){ node = newNode; }else{ //获取根节点 let current = node; let parent; while(true){ //将当前节点保存为父节点 parent = current; //将小的数据放在左节点 if(data &lt; current.data){ //获取当前节点的左节点 //判断当前节点下的左节点是否有数据 current = current.left; if(current == null){ //如果没有数据将新节点存入当前节点下的左节点 parent.left = newNode; break; } }else{ current = current.right; if(current == null){ parent.right = newNode; break; } } } } } 翻转二叉树 function invertTree(node) { if (node !== null) { node.left, node.right = node.left, node.right; invertTree(node.left); invertTree(node.right); } return node; }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现常用排序]]></title>
    <url>%2F2018%2F11%2F21%2FJavaScript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一、冒泡排序//相邻两个数之间进行排序 //外层长度为length //内层长度为length-1-i,因为内层比较的时候会j+1，所以这里是length-1 //第一次内层循环完会把最大的一个数放在最后，然后又从第一位开始循环。 function bubbleSort(arr){ for(let i = 0; i &lt; arr.length; i++){ for(let j = 0; j &lt; arr.length-1-i; j++){ if(arr[j]&gt;arr[j+1]){ let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } return arr } 二、选择排序//内层每循环完一次会找出最小的数 //外层长度为length-1,因为内层j=i+1 //第一次循环会把最小的数放在最前面,然后从下一位开始循环 function selectSort(arr){ for(let i = 0; i &lt; arr.length-1; i++){ let minIndex = i; for(let j = i +1; j &lt; arr.length; j++){ if(arr[j]&lt;arr[minIndex]){ minIndex = j; } } let temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; //在最小的数所在的位置，设置为查找的第一个数 } return arr; } 三、插入排序//current为拿出去缓存的数 //如果current前面的数比它大，会把这个数向后移动一位。然后再比较前一位与current的大小 //第一次循环，会判断第二个数，也就是缓存的数在前两位数组中大小的位置。然后再比较第三个数在前三位数组中大小的位置。 function insertSort(arr){ for(let i = 1; i &lt; arr.length; i++){ let current = arr[i]; let preIndex = i-1; while(preIndex &gt;=0; arr[preIndex] &gt; current){ arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } 四、快速排序//先设置一个中间值 //把小于中间值的放在左边，把大于中间值的放在右边 //重复前面两个步骤 function quickSort(arr){ if(arr.length &lt;=1 ){ return arr; } let pivotIndex = Math.floor(arr.length/2); let pivot = arr.splice(pivotIndex,1); //截取中间值，如果此处使用pivot=arr[index]; 那么将会出现无限递归的错误 let left = []; let right = []; for(let i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; pivot){ left.push(arr[i]); }else{ right.push(arr[i]); } } return quickSort(left).concat(pivot,quickSort(right)); } 五、归并排序//归并排序是一种分治算法。 //本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置。 //接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 function mergeSort(arr) { let len = arr.length; if(len &lt; 2) { return arr; } let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right){ let result = []; while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } result.push(...left); result.push(...right); return result; } 六、堆排序1）索引0是树的根节点； 2）除根节点为，任意节点N的父节点是N/2； 3）节点L的左子节点是2*L； 4）节点R的右子节点为2*R + 1 // 本质上就是先构建二叉树，然后把根节点与最后一个进行交换， //然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { //建立大顶堆 len = arr.length; for (let i = Math.floor(len / 2); i &gt;= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { //堆调整 let left = 2 * i + 1; let right = 2 * i + 2; let largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if (largest !== i) { [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(arr, largest); } } function heapSort(arr) { buildMaxHeap(arr); for (let i = arr.length - 1; i &gt; 0; i--) { [arr[0],arr[i]]=[arr[i],arr[0]]; len--; heapify(arr, 0); } return arr; } 七、二分查找（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。 （2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。 （3）如果某一步数组为空，则表示找不到目标元素。 function binary_search(arr, key) { let low = 0; let high = arr.length - 1; while(low &lt;= high){ let mid = parseInt((high + low) / 2); if(key === arr[mid]){ return mid; }else if(key &gt; arr[mid]){ low = mid + 1; }else if(key &lt; arr[mid]){ high = mid -1; }else{ return -1; } } }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用布局实现]]></title>
    <url>%2F2018%2F11%2F01%2Fcss%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[布局方式1.标准文档流 2.浮动布局 其它盒子在定位的时候，会忽略浮动布局定位的元素，但是其它盒子内的文本依然会为这个元素让出位置，环绕在四周。 3.定位布局值为static和relative时不会脱离文档流。 值为absolute和fixed时元素会脱离文档流。 绝对定位时，其它盒子在定位时，也会忽略绝对定位的元素，而且其它盒子内的文本也会忽略这个元素。 4.flex布局概念：main axis（主轴）,cross axis（交叉轴）,container(父容器)，item（子容器）。 父容器属性：设置主轴的方向: flex-direction: row //向右，默认 column //向下 row-reverse //向左 column-reverse //向上 设置所有子容器怎样沿主轴排列（横轴）： justify-content: flex-start //起始端对齐 flex-end //末尾端对齐 center //居中对齐 space-around //子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。 space-between //子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。 设置所有子容器怎样沿交叉轴排列（纵轴）： align-items： flex-start //起始端对齐 flex-end //末尾端对齐 center //居中对齐 baseline //基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。 stretch //子容器沿纵轴方向的尺寸拉伸至与父容器一致。 设置所有子容器换行方式： flex-wrap: nowrap //不换行 wrap //换行 wrap-reverse //逆序换行 轴与换行组合： flex-flow: 当子容器多行排列时，设置行与行之间的对齐方式。： align-content: flex-start flex-end center baseline stretch 子容器属性设置单个子容器在主轴上如何伸缩： flex: 单值（flex-grow或者flex-basis）：1;10em/30px/auto/content/10% 双值（flex-grow|flex-basis或者flex-shink）:1 30px;1 1 三值（flex-grow|flex-shink|flex-basis）：1 1 10% 设置单个子容器如何沿纵轴排列： align-self: flex-start flex-end center baseline stretch 设置在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度: flex-basis: 设置子容器弹性伸展的比例,把剩余空间按比列分配给子元素： flex-grow:1 flex-grow:2 //前面一个占1后面一个占2 设置子容器弹性伸展的比例,超出部分按比列从子容器中减去： flex-shrink:1 flex-shrink:2 //前面一个减去超出部分的1，后面一个减去超出部分的2 设置排列顺序： order: //默认值为 0，可以为负值，数值越小排列越靠前。 一、水平居中文本/行内元素/行内块级元素水平居中.parent{ text-align: center; } 单个块级元素水平居中.son{ width: 100px; /*必须定宽*/ margin: 0 auto; } 多个块级元素水平居中.parent{ text-align: center; } .son{ display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/ } 利用绝对定位水平居中.parent{ height: 200px; width: 200px; /*定宽*/ position: relative; /*父相*/ background-color: #f00; } .son{ position: absolute; /*子绝*/ left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00; } 任意个元素，利用flex水平居中.parent{ display: flex; justify-content: center; } 二、垂直居中单行文本/行内元素/行内块级元素 垂直居中.parent{ height: 150px; line-height: 150px; /*与height等值*/ } 多行文本/行内元素/行内块级元素 垂直居中.parent{ /*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/ height: 150px; line-height: 30px; /*元素在页面呈现为5行,则line-height的值为height/5*/ } 图片垂直居中.parent{ height: 150px; line-height: 150px; font-size: 0; } .son-img{vertical-align: middle;} /*默认是基线对齐，改为middle*/ 单个块级元素 垂直居中使用table-cell实现： .parent{ display: table-cell; vertical-align: middle; } 使用绝对定位实现: 原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的*/ .parent{ height: 150px; position: relative; /*父相*/ } .son{ position: absolute; /*子绝*/ top: 50%; /*父元素高度一半,这里等同于top:75px;*/ transform: translateY(-50%); /*自身高度一半,这里等同于margin-top:-25px;*/ height: 50px; } /*优缺点 优点：使用margin-top兼容性好；不管是块级还是行内元素都可以实现 缺点：代码较多；脱离文档流；使用margin-top需要知道高度值；使用transform兼容性不好（ie9+）*/ 或 /*原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分*/ .parent{position: relative;} .son{ position: absolute; margin: auto 0; top: 0; bottom: 0; height: 50px; } /*优缺点 优点：简单;兼容性较好(ie8+) 缺点：脱离文档流*/ 使用flex实现： .parent{ display: flex; align-items: center; } 或 .parent{display: flex;} .son{align-self: center;} 或 /*原理：这个尚未搞清楚，应该是flex使margin上下边界无限延伸至剩余空间并平分了*/ .parent{display: flex;} .son{margin: auto 0;} 任意个元素利用flex实现.parent{ display: flex; align-items: center; } 或 .parent{ display: flex; } .son{ align-self: center; } 或 .parent{ display: flex; flex-direction: column; justify-content: center; } 三、水平垂直居中行内/行内块级/图片 水平垂直居中.parent{ height: 150px; line-height: 150px; /*行高的值与height相等*/ text-align: center; font-size: 0; /*消除幽灵空白节点的bug*/ } .son{ /*display: inline-block;*/ /*如果是块级元素需改为行内或行内块级才生效*/ vertical-align: middle; } 利用table-cell实现 水平垂直居中.parent{ height: 150px; width: 200px; display: table-cell; vertical-align: middle; /*text-align: center;*/ /*如果是行内元素就添加这个*/ } .son{ /*margin: 0 auto;*/ /*如果是块级元素就添加这个*/ width: 100px; height: 50px; } 利用button作为父元素 实现 水平垂直居中.parent-button{ /*改掉button默认样式就好了,不需要居中处理*/ height: 150px; width: 200px; outline: none; border: none; } .son{ display: inline-block; /*button自带text-align: center,改为行内水平居中生效*/ } 绝对定位水平垂直居中.parent{ position: relative; } .son{ position: absolute; top: 50%; left: 50%; /*定宽高时等同于margin-left:负自身宽度一半;margin-top:负自身高度一半;*/ transform: translate(-50%,-50%); } 或 .parent{ position: relative; } .son{ position: absolute; margin: auto; width: 100px; height: 50px; top: 0; bottom: 0; left: 0; right: 0; } flex 水平垂直居中.parent{ display: flex; } .son{ margin: auto; } 或 .parent{ display: flex; justify-content: center; align-items: center; } 或 .parent{ display: flex; justify-content: center; } .son{ align-self: center; } 视窗水平垂直居中原理：vh为视口单位，视口即文档可视的部分，50vh就是视口高度的50/100，设置50vh上边距 .son{ /*0如果去掉，则会多出滚动条并且上下都是50vh的margin。如果去掉就给body加上overflow:hidden;*/ margin: 50vh auto 0; transform: translateY(-50%); } 四、两列布局左列定宽，右列自适应1.利用float+margin实现 .left { background-color: #f00; float: left; width: 100px; height: 500px; } .right { background-color: #0f0; height: 500px; margin-left: 100px; /*大于等于#left的宽度*/ } 2.利用float+overflow实现 .left { background-color: #f00; float: left; width: 100px; height: 500px; } .right { background-color: #0f0; height: 500px; overflow: hidden; /*触发bfc达到自适应*/ } 3.利用table实现 .parent{ width: 100%; display: table; height: 500px; } .left { width: 100px; background-color: #f00; } .right { background-color: #0f0; } .left,#right{ display: table-cell; /*利用单元格自动分配宽度*/ } 4.利用绝对定位实现 .parent{ position:relative; } .left { position:absolute; background-color: #f00; width: 100px; height: 500px; } .right { position:absolute; left:100px; right:0px; background-color: #0f0; height: 500px; } 5.利用flex实现 .parent{ display:flex; } .left { background-color: #f00; width: 100px; height: 500px; } .right { flex:1; background-color: #0f0; height: 500px; } 6.利用grid（网格）实现 .parent{ display:grid; grid-template-columns:100px auto; } .left { background-color: #f00; } .right { background-color: #0f0; } 左列自适应，右列定宽1.利用float+margin实现 .parent{ padding-left:100px;//为了抵消margin-left:-100px } .left { width:100%; float:left; margin-left:-100px; background-color: #f00; } .right { width:100px; float:right; background-color: #0f0; } 2.利用float+overflow实现 //这里左右列的标签要换一下 &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;right&quot;&gt;右列定宽&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左列自适应&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; .left { overflow: hidden; /*触发bfc*/ background-color: #f00; } .right { float: right; width: 100px; background-color: #0f0; } 3.利用table实现 .parent{ display:table; width:100%; } .left { display:table-cell; background-color: #ff0; } .right { display:table-cell; width: 100px; background-color: #0f0; } 4.利用绝对定位实现 .parent{ position:relative; } .left { position:absolute; right:100px; left:0px; background-color: #ff0; } .right { position:absolute; right:0px; width: 100px; background-color: #0f0; } 5.利用flex实现 .parent{ display:flex; } .left { flex:1; background-color: #f00; } .right { width: 100px; background-color: #0f0; } 6.利用grid实现 .parent{ display:grid; grid-template-columns:auto 100px; } .left { background-color: #ff0; } .right { background-color: #0f0; } 左列不定宽，右列自适应1.利用float+overflow实现 .left { float:left; background-color: #f00; } .right { overflow:hidden; background-color: #0f0; } 2.利用flex实现 .parent{ display:flex; } .left { background-color: #ff0; } .right { flex:1; background-color: #0f0; } 3.利用grid实现 .parent{ display:grid; grid-template-columns:auto 1fr; } .left { background-color: #f00; } .right { flex:1; background-color: #0f0; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2018%2F08%2F28%2FES6%2F</url>
    <content type="text"><![CDATA[函数总体规则 不在函数内定义的变量具有全局作用域，所有的全局作用域变量被绑定到window的一个属性 内部函数变量可以访问外部函数变量 如果内部函数变量和外部函数变量名相同，内部函数变量会屏蔽外部函数变量 let块级作用域变量用var声明的变量作用于函数内部： function foo() { for (var i=0; i&lt;100; i++) { } i += 100; // 仍然可以引用变量i } 用let声明的变量： function foo() { var sum = 0; for (let i=0; i&lt;100; i++) { sum += i; } // SyntaxError:这里会报错 i += 1; } 注：const是具有块级作用域的常量，通常大写表示 解构赋值对多个变量进行赋值： var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;]; 多个变量嵌套赋值： let [x, [y, z]] = [&apos;hello&apos;, [&apos;JavaScript&apos;, &apos;ES6&apos;]]; 取一个对象中的若干数据赋值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos; }; var {name, age, passport} = person;//这里name,age,passport会分别被赋值对应属性 取一个对象中的数据，进行嵌套赋值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;, address: { city: &apos;Beijing&apos;, street: &apos;No.1 Road&apos;, zipcode: &apos;100001&apos; } }; var {name, address: {city, zip}} = person;//city,zip被赋值 //注意：这里的address不是变量，而是为了获得里面的数据对象的属性，直接访问会报not defined错误 如果变量对应的属性不存在，变量将被赋值为undefined。如果要使用变量名和属性名不一样，可以使用下面的语句： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos; }; // 把passport属性赋值给变量id: let {name, passport:id} = person;//id=&apos;G-123456&apos; //注意这里的passport也不是变量，和address类似。 解构赋值使用默认值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos; }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; Array的相关高阶函数map()方法定义在JavaScript的Array中，用来对Array中的每个元素进行相同的操作，比如对Array中的每个元素进行求平方： function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] console.log(results); reduce（）方法也是定义在JavaScript的Array中，reduce()把结果继续和序列的下一个元素做累计计算，比如对Array中的数组求和： var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 filter()函数用于把Array的某些元素过滤掉，然后返回剩下的元素。比如删掉Array中的偶数，只保留奇数: var arr = [1, 2, 4, 5, 6, 9, 10, 15]; var r = arr.filter(function (x) { return x % 2 !== 0; }); r; // [1, 5, 9, 15] sort()函数用于排序。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1 //注意：sort()方法默认把所有元素先转换为String，然后在根据字符的ASCII码进行排序 sort()可以接受一个比较函数来实现自定义排序，比如对一个数组按数字大小排序： var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { if (x &lt; y) { return -1; } if (x &gt; y) { return 1; } return 0; }); console.log(arr); // [1, 2, 10, 20] generator（生成器）generator生成器是ES6标准引入的新的数据类型。由function*定义，并且，除了return语句，还可以用yield返回多次。 比如利用generator函数生成一个斐波那契数列，它由0，1开头：0 1 1 2 3 5 8 13 21 34 … function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return; } 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法 var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} 第二个方法是直接用for … of循环迭代generator对象，这种方式不需要我们自己判断done： for (var x of fib(5)) { console.log(x); // 依次输出0, 1, 1, 2, 3, ... } 面向对象编程class继承1.子类必须在constructor方法中调用super方法 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class Student1 { constructor(name) { this.name = name; } hello() { alert(&apos;Hello, &apos; + this.name); } } class PrimaryStudent1 extends Student1 { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert(&apos;I am at grade &apos; + this.grade); } } var myStudent = new PrimaryStudent1(&apos;this is name1&apos;,&apos;this is grade1&apos;) myStudent.hello();// hello,this is name1 myStudent.myGrade();//I am at grade this is grade1 Promise在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。 一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败： function test(resolve, reject) { var timeOut = Math.random() * 2; log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;); setTimeout(function () { if (timeOut &lt; 1) { log(&apos;call resolve()...&apos;); resolve(&apos;200 OK&apos;); } else { log(&apos;call reject()...&apos;); reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;); } }, timeOut * 1000); } new Promise(test).then(function (result) { console.log(&apos;成功：&apos; + result); }).catch(function (reason) { console.log(&apos;失败：&apos; + reason); }); Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写： job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是Promise对象。 resolve 表示异步操作执行成功后的回调函数，reject 表示异步操作执行失败后的回调函数。 then接收resovle传递的数据，catch接收reject传递的数据。 next( 1 ).then( function( res ){ console.log( &apos;resolve:&apos; +res ); } ).catch( function( res ){ console.log( &apos;reject:&apos; + res ); } ); 字符串ES6模板语法连接字符串: var name = &apos;小明&apos;; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; alert(message); 获取字符串的长度： var s = &apos;Hello, world!&apos;; s.length; // 13 获取字符串某个指定位置字符, .charAt()方法有相同的功能： var s = &apos;Hello, world!&apos;; s[0]; // &apos;H&apos; s[6]; // &apos; &apos; s[7]; // &apos;w&apos; s[12]; // &apos;!&apos; s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined //注意：空字符也占一个位置。同时字符串是不可变的，如果对字符串某个索引赋值，不会有任何效果。 字符串方法：调用这些方法本身不会改变原有字符串的内容，而是返回一个新的字符串charAt()返回指定位置的字符 charCodeAt()返回指定位置的字符的Unicode编码 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf()搜索指定字符串出现的位置： var s = &apos;hello, world&apos;; s.indexOf(&apos;world&apos;); // 返回7 s.indexOf(&apos;World&apos;); // 没有找到指定的子串 lastIndexOf()返回字符串最后出现的位置 substring()返回指定索引区间的子串： var s = &apos;hello, world&apos; s.substring(0, 5); // **从索引0开始到5（不包括5）**，返回&apos;hello&apos; s.substring(7); // 从索引7开始到结束，返回&apos;world&apos; split(separator,howmany)按分隔符分割字符串数组，第一个参数必需，分割符，第二个参数可选，表示返回新字符串数组的最大长度： var str=&apos;How are you?&apos; str.split(&apos; &apos;) //How,are,you? str.split(&apos;&apos;) //H,o,w, ,a,r,e, ,y,o,u,? str.split(&apos; &apos;,2) //How,are trim()去掉字符串首尾的空格 var greeting = &apos; Hello world! &apos;; console.log(greeting.trim()); // expected output: &quot;Hello world!&quot;; 数组方法indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;]; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;] arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] // 只删除,不添加: arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;] arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;] // 只添加,不删除: arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素 arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] //如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： push()和pop() push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： var arr = [1, 2]; arr.push(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4 arr; // [1, 2, &apos;A&apos;, &apos;B&apos;] arr.pop(); // pop()返回&apos;B&apos; arr; // [1, 2, &apos;A&apos;] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] unshift()和shift() 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： var arr = [1, 2]; arr.unshift(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4 arr; // [&apos;A&apos;, &apos;B&apos;, 1, 2] arr.shift(); // &apos;A&apos; arr; // [&apos;B&apos;, 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] sort()sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： var arr = [&apos;B&apos;, &apos;C&apos;, &apos;A&apos;]; arr.sort(); arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] reversereverse()把整个Array的元素给掉个个，也就是反转： var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]; arr.reverse(); arr; // [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; var added = arr.concat([1, 2, 3]); added; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3] arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] //注意concat()方法并没有修改当前Array，而是返回了一个新的Array。 joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3]; arr.join(&apos;-&apos;); // &apos;A-B-C-1-2-3&apos; includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 var array1 = [1, 2, 3]; console.log(array1.includes(2)); // expected output: true MapMap是一组键值对的结构，具有极快的查找速度。 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 循环for…infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来： var o = { name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos; }; for (var key in o) { console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos; } for…of循环是ES6引入的新的语法: var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]); var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]); for (var x of a) { // 遍历Array console.log(x); } for (var x of s) { // 遍历Set console.log(x); } for (var x of m) { // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]); } forEach更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + &apos;, index = &apos; + index); }); 浏览器对象windowwindows对象不但充当全局作用域，而且表示浏览器窗口。 window.innerWidth浏览器窗口内部宽度，window.outerwidth浏览器窗口整个宽度。window.innerHeight浏览器窗口内部高度，window.outerHeight浏览器窗口整个高度//外部是浏览器窗口整个的大小，内部窗口是页面能显示的窗口大小。 navigatornavigator对象表示浏览器的信息。 navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 screenscrenn对象表示屏幕的信息。 screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。//如果你的windows把屏幕放大为125%，那么1920x1080的屏幕会显示为1536x864。 locationlocation对象表示当前页面的URL信息。例如，一个完整的URL： http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： location.protocol; // &apos;http&apos; location.host; // &apos;www.example.com&apos; location.port; // &apos;8080&apos; location.pathname; // &apos;/path/index.html&apos; location.search; // &apos;?a=1&amp;b=2&apos; location.hash; // &apos;TOP&apos; location.origin //http://www.example.com location.href// http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，可以调用location.reload()。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
