<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cookies、session、LocalStorage、SessionStorage的区别]]></title>
    <url>%2F2018%2F11%2F24%2FCookies%E3%80%81session%E3%80%81LocalStorage%E3%80%81SessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[cookie和session HTML4提供的缓存机制，都是用来跟踪浏览器用户身份的会话方式。 Local Storage和Session Storage HTML5提供的本地缓存机制，只能存储字符串类型。 sessionStorage：仅在当前浏览器窗口关闭前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存；cookie只在设置的cookie过期时间之前一直有效。 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 cookie：1.cookie保存在浏览器内存中，大小限制为4kb，随浏览器关闭而结束。如果设置了过期时间，会被保存在硬盘中，关闭浏览器后，数据仍然存在，知道过期时间结束才消失。 2.cookie应用于判断用户是否登陆过网站，以便下次登陆时能够自动登陆。 3.cookie安全信较低，每次访问都要传送cooki给服务器。 session：1.session保存在服务器端，没有大小限制，当服务器收到创建session对象请求时，如果客户端的请求包含sessionid，服务器返回sessionid对应的session对象。如果没有sessionid,服务器会创建sessionid和session对象返回给客户端。通常使用cookie方式存储sessionid到客户端。 2.session用于保存每个用户的专用信息，通过seeionID来区分不同的客户。比如用户的登陆信息，购物车信息等。 3.要先攻破cookie才能攻破session，如果存用户信息过多，会占用服务器内存。 Local Storage:1.永久保存在客户端的本地硬盘中。即使浏览器关闭了，下次访问该网站时仍能使用。 Session Storage:1.将数据保存在session对象中。生命周期为进入网站，直到浏览器窗口关闭的这段时间。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>网络缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络相关协议]]></title>
    <url>%2F2018%2F11%2F24%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[应用层：FTP（File Transfer Protocol）:可靠的文件传输协议。 TFTP（Trivial File Transfer Protocol）：不可靠的小文件传输协议。 HTTP（HyperText Transfer Protocol）：超文本传输协议。使用SSL加密后的安全网络协议为HTTPS。 SMTP（Simple Mail Transfer Protocol）和POP3（Post Office Protocol - Version 3）：邮件传输协议，邮件报文采用ASCII格式表示。 Telnet:远程连接协议。 SNMP（Simple Network Management Protocol）：简单网络管理协议，必须以管理员的身份登录才能完成配置。 DHCP（Dynamic Host Configuration Protocol）：动态分配IP地址协议，DHCP客户端能从DHCP服务器获得DHCP服务器的IP地址、DNS服务器的IP地址、默认网关的IP地址等。 DNS（Domain Name System）：将域名解析为IP地址。分为递归查询和迭代查询。 递归查询：主机提出一个查询请求，本地服务器会自动一层一层的查询下去，直到找到满足查询请求的IP地址，再返回给主机。即问一次，就得到最终结果。 迭代查询：服务器收到一次查询请求，就回答一次。但回答的不一定是最终地址，也可能是其他层次服务器的地址。然后客户端再去提交查询请求。即问一次答一次，而后再去问其他服务器，直到问道结果。 WEP（Wired Equivalent Privacy）：有线等价协议。两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。 传输层：TCP（Transmission Control Protocol）：可靠连接。 UDP（User Datagram Protocol）：不可靠连接。 网络层：IP（Internet Protocol）：最重要的核心协议，无连接、不可靠。 ICMP（Internet Control Message Protocol）：因特网控制信息协议，用来检测网络通信是否顺畅。 ARP（Address Resolution Protocol和RARP（Reverse Address Resolution Protocol）：地址解析协议。ARP是把IP地址解析为MAC物理地址，RARP是把MAC物理地址解析为IP地址。 IGMP（Internet Group Management Protocol）：网络组管理协议。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从URL到页面显示发生了什么]]></title>
    <url>%2F2018%2F11%2F22%2F%E4%BB%8EURL%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[一、在浏览器地址栏输入URL浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 二、进行DNS域名解析浏览器解析URL获取协议，主机，端口，PATH。把这些请求组装一个HTTP（GET）请求报文: //首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF //首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束 //请求头和消息实体之间有一个CRLF分隔 //根据实际请求需要可能包含一个消息实体 GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1 Host: www.w3.org Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 Referer: https://www.google.com.hk/ Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: authorstyle=yes If-None-Match: &quot;2cc8-3e3073913b100&quot; If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT name=qiu&amp;age=25 浏览器获取主机ip地址，解析的查找顺序依次为： 1.浏览器自身的DNS缓存 2.本机DNS缓存 //存放在内存中，关机就消失 3.hosts文件 //存放在系统文件夹中 4.路由器缓存 5.DNS域名服务器 6.根域名服务器。 DNS服务器的分级查询： 主机名.次级域名.顶级域名.根域名 = www.google.com.root //一般root会被省略，因为对于所有的域名都是一样的。全世界有13台根服务器，域名为a.root-servers.net 到m.root-servers.net。 所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下： 1.从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的NS记录和A记录（IP地址） 2.从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的NS记录和A记录（IP地址） 3.从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的IP地址 //NS记录（Name Server的缩写），即哪些服务器负责管理google.com的DNS记录。 根域名服务器分布： 查找方式分为两种： 迭代和递归。简单来说，迭代查询就是需要本地服务器自己去找，而递归查询是其它其它服务器直接把查询好的结果告诉它。 三、根据目标IP地址，端口建立TCP链接进行TCP协议三次握手： 1.主机向服务器发送一个建立连接的请求（您好，我想认识您）；2.服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；3.主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。//结束断开的时候为四次挥手 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z 四、服务器将响应报文，返回HTTP报文给浏览器服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 返回的HTTP报文如下： //首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF //首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束 //请求头和消息实体之间有一个CRLF分隔 //根据实际请求需要可能包含一个消息实体 一个请求报文例子如下： GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1 Host: www.w3.org Connection: keep-alive Cache-Control: max-age=0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 Referer: https://www.google.com.hk/ Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: authorstyle=yes If-None-Match: &quot;2cc8-3e3073913b100&quot; If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt; &lt;/html&gt; 五、浏览器解析渲染页面浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本： 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面）]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树相关]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[创建 function Node(data,left,right){ this.data = data;//数值 this.left = left;//左节点 this.right = right;//右节点 }; 插入二叉树 function insert(node,data){ //创建一个新的节点 let newNode = new Node(data,null,null); //判断是否存在根节点，没有将新节点存入 if(node == null){ node = newNode; }else{ //获取根节点 let current = node; let parent; while(true){ //将当前节点保存为父节点 parent = current; //将小的数据放在左节点 if(data &lt; current.data){ //获取当前节点的左节点 //判断当前节点下的左节点是否有数据 current = current.left; if(current == null){ //如果没有数据将新节点存入当前节点下的左节点 parent.left = newNode; break; } }else{ current = current.right; if(current == null){ parent.right = newNode; break; } } } } } 翻转二叉树 function invertTree(node) { if (node !== null) { node.left, node.right = node.left, node.right; invertTree(node.left); invertTree(node.right); } return node; }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现常用排序]]></title>
    <url>%2F2018%2F11%2F21%2FJavaScript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一、冒泡排序//相邻两个数之间进行排序 //外层长度为length //内层长度为length-1-i,因为内层比较的时候会j+1，所以这里是length-1 //第一次内层循环完会把最大的一个数放在最后，然后又从第一位开始循环。 function bubbleSort(arr){ for(let i = 0; i &lt; arr.length; i++){ for(let j = 0; j &lt; arr.length-1-i; j++){ if(arr[j]&gt;arr[j+1]){ let temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } return arr } 二、选择排序//内层每循环完一次会找出最小的数 //外层长度为length-1,因为内层j=i+1 //第一次循环会把最小的数放在最前面,然后从下一位开始循环 function selectSort(arr){ for(let i = 0; i &lt; arr.length-1; i++){ let minIndex = i; for(let j = i +1; j &lt; arr.length; j++){ if(arr[j]&lt;arr[minIndex]){ minIndex = j; } } let temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; //在最小的数所在的位置，设置为查找的第一个数 } return arr; } 三、插入排序//current为拿出去缓存的数 //如果current前面的数比它大，会把这个数向后移动一位。然后再比较前一位与current的大小 //第一次循环，会判断第二个数，也就是缓存的数在前两位数组中大小的位置。然后再比较第三个数在前三位数组中大小的位置。 function insertSort(arr){ for(let i = 1; i &lt; arr.length; i++){ let current = arr[i]; let preIndex = i-1; while(preIndex &gt;=0; arr[preIndex] &gt; current){ arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current; } return arr; } 四、快速排序//先设置一个中间值 //把小于中间值的放在左边，把大于中间值的放在右边 //重复前面两个步骤 function quickSort(arr){ if(arr.length &lt;=1 ){ return arr; } let pivotIndex = Math.floor(arr.length/2); let pivot = arr.splice(pivotIndex,1); //截取中间值，如果此处使用pivot=arr[index]; 那么将会出现无限递归的错误 let left = []; let right = []; for(let i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; pivot){ left.push(arr[i]); }else{ right.push(arr[i]); } } return quickSort(left).concat(pivot,quickSort(right)); } 五、归并排序//归并排序是一种分治算法。 //本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置。 //接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组 function mergeSort(arr) { let len = arr.length; if(len &lt; 2) { return arr; } let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right){ let result = []; while (left.length &amp;&amp; right.length) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } result.push(...left); result.push(...right); return result; } 六、堆排序1）索引0是树的根节点； 2）除根节点为，任意节点N的父节点是N/2； 3）节点L的左子节点是2*L； 4）节点R的右子节点为2*R + 1 // 本质上就是先构建二叉树，然后把根节点与最后一个进行交换， //然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个 var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { //建立大顶堆 len = arr.length; for (let i = Math.floor(len / 2); i &gt;= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { //堆调整 let left = 2 * i + 1; let right = 2 * i + 2; let largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if (largest !== i) { [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(arr, largest); } } function heapSort(arr) { buildMaxHeap(arr); for (let i = arr.length - 1; i &gt; 0; i--) { [arr[0],arr[i]]=[arr[i],arr[0]]; len--; heapify(arr, 0); } return arr; } 七、二分查找（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。 （2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。 （3）如果某一步数组为空，则表示找不到目标元素。 function binary_search(arr, key) { let low = 0; let high = arr.length - 1; while(low &lt;= high){ let mid = parseInt((high + low) / 2); if(key === arr[mid]){ return mid; }else if(key &gt; arr[mid]){ low = mid + 1; }else if(key &lt; arr[mid]){ high = mid -1; }else{ return -1; } } }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用布局实现]]></title>
    <url>%2F2018%2F11%2F01%2Fcss%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[布局方式1.标准文档流 2.浮动布局 其它盒子在定位的时候，会忽略浮动布局定位的元素，但是其它盒子内的文本依然会为这个元素让出位置，环绕在四周。 3.定位布局值为static和relative时不会脱离文档流。 值为absolute和fixed时元素会脱离文档流。 绝对定位时，其它盒子在定位时，也会忽略绝对定位的元素，而且其它盒子内的文本也会忽略这个元素。 4.flex布局概念：main axis（主轴）,cross axis（交叉轴）,container(父容器)，item（子容器）。 父容器属性：设置主轴的方向: flex-direction: row //向右，默认 column //向下 row-reverse //向左 column-reverse //向上 设置所有子容器怎样沿主轴排列（横轴）： justify-content: flex-start //起始端对齐 flex-end //末尾端对齐 center //居中对齐 space-around //子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。 space-between //子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。 设置所有子容器怎样沿交叉轴排列（纵轴）： align-items： flex-start //起始端对齐 flex-end //末尾端对齐 center //居中对齐 baseline //基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。 stretch //子容器沿纵轴方向的尺寸拉伸至与父容器一致。 设置所有子容器换行方式： flex-wrap: nowrap //不换行 wrap //换行 wrap-reverse //逆序换行 轴与换行组合： flex-flow: 当子容器多行排列时，设置行与行之间的对齐方式。： align-content: flex-start flex-end center baseline stretch 子容器属性设置单个子容器在主轴上如何伸缩： flex: 单值（flex-grow或者flex-basis）：1;10em/30px/auto/content/10% 双值（flex-grow|flex-basis或者flex-shink）:1 30px;1 1 三值（flex-grow|flex-shink|flex-basis）：1 1 10% 设置单个子容器如何沿纵轴排列： align-self: flex-start flex-end center baseline stretch 设置在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度: flex-basis: 设置子容器弹性伸展的比例,把剩余空间按比列分配给子元素： flex-grow:1 flex-grow:2 //前面一个占1后面一个占2 设置子容器弹性伸展的比例,超出部分按比列从子容器中减去： flex-shrink:1 flex-shrink:2 //前面一个减去超出部分的1，后面一个减去超出部分的2 设置排列顺序： order: //默认值为 0，可以为负值，数值越小排列越靠前。 一、水平居中文本/行内元素/行内块级元素水平居中.parent{ text-align: center; } 单个块级元素水平居中.son{ width: 100px; /*必须定宽*/ margin: 0 auto; } 多个块级元素水平居中.parent{ text-align: center; } .son{ display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/ } 利用绝对定位水平居中.parent{ height: 200px; width: 200px; /*定宽*/ position: relative; /*父相*/ background-color: #f00; } .son{ position: absolute; /*子绝*/ left: 50%; /*父元素宽度一半,这里等同于left:100px*/ transform: translateX(-50%); /*自身宽度一半,等同于margin-left: -50px;*/ width: 100px; /*定宽*/ height: 100px; background-color: #00ff00; } 任意个元素，利用flex水平居中.parent{ display: flex; justify-content: center; } 二、垂直居中单行文本/行内元素/行内块级元素 垂直居中.parent{ height: 150px; line-height: 150px; /*与height等值*/ } 多行文本/行内元素/行内块级元素 垂直居中.parent{ /*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/ height: 150px; line-height: 30px; /*元素在页面呈现为5行,则line-height的值为height/5*/ } 图片垂直居中.parent{ height: 150px; line-height: 150px; font-size: 0; } .son-img{vertical-align: middle;} /*默认是基线对齐，改为middle*/ 单个块级元素 垂直居中使用table-cell实现： .parent{ display: table-cell; vertical-align: middle; } 使用绝对定位实现: 原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的*/ .parent{ height: 150px; position: relative; /*父相*/ } .son{ position: absolute; /*子绝*/ top: 50%; /*父元素高度一半,这里等同于top:75px;*/ transform: translateY(-50%); /*自身高度一半,这里等同于margin-top:-25px;*/ height: 50px; } /*优缺点 优点：使用margin-top兼容性好；不管是块级还是行内元素都可以实现 缺点：代码较多；脱离文档流；使用margin-top需要知道高度值；使用transform兼容性不好（ie9+）*/ 或 /*原理：当top、bottom为0时,margin-top&amp;bottom会无限延伸占满空间并且平分*/ .parent{position: relative;} .son{ position: absolute; margin: auto 0; top: 0; bottom: 0; height: 50px; } /*优缺点 优点：简单;兼容性较好(ie8+) 缺点：脱离文档流*/ 使用flex实现： .parent{ display: flex; align-items: center; } 或 .parent{display: flex;} .son{align-self: center;} 或 /*原理：这个尚未搞清楚，应该是flex使margin上下边界无限延伸至剩余空间并平分了*/ .parent{display: flex;} .son{margin: auto 0;} 任意个元素利用flex实现.parent{ display: flex; align-items: center; } 或 .parent{ display: flex; } .son{ align-self: center; } 或 .parent{ display: flex; flex-direction: column; justify-content: center; } 三、水平垂直居中行内/行内块级/图片 水平垂直居中.parent{ height: 150px; line-height: 150px; /*行高的值与height相等*/ text-align: center; font-size: 0; /*消除幽灵空白节点的bug*/ } .son{ /*display: inline-block;*/ /*如果是块级元素需改为行内或行内块级才生效*/ vertical-align: middle; } 利用table-cell实现 水平垂直居中.parent{ height: 150px; width: 200px; display: table-cell; vertical-align: middle; /*text-align: center;*/ /*如果是行内元素就添加这个*/ } .son{ /*margin: 0 auto;*/ /*如果是块级元素就添加这个*/ width: 100px; height: 50px; } 利用button作为父元素 实现 水平垂直居中.parent-button{ /*改掉button默认样式就好了,不需要居中处理*/ height: 150px; width: 200px; outline: none; border: none; } .son{ display: inline-block; /*button自带text-align: center,改为行内水平居中生效*/ } 绝对定位水平垂直居中.parent{ position: relative; } .son{ position: absolute; top: 50%; left: 50%; /*定宽高时等同于margin-left:负自身宽度一半;margin-top:负自身高度一半;*/ transform: translate(-50%,-50%); } 或 .parent{ position: relative; } .son{ position: absolute; margin: auto; width: 100px; height: 50px; top: 0; bottom: 0; left: 0; right: 0; } flex 水平垂直居中.parent{ display: flex; } .son{ margin: auto; } 或 .parent{ display: flex; justify-content: center; align-items: center; } 或 .parent{ display: flex; justify-content: center; } .son{ align-self: center; } 视窗水平垂直居中原理：vh为视口单位，视口即文档可视的部分，50vh就是视口高度的50/100，设置50vh上边距 .son{ /*0如果去掉，则会多出滚动条并且上下都是50vh的margin。如果去掉就给body加上overflow:hidden;*/ margin: 50vh auto 0; transform: translateY(-50%); } 四、两列布局左列定宽，右列自适应1.利用float+margin实现 .left { background-color: #f00; float: left; width: 100px; height: 500px; } .right { background-color: #0f0; height: 500px; margin-left: 100px; /*大于等于#left的宽度*/ } 2.利用float+overflow实现 .left { background-color: #f00; float: left; width: 100px; height: 500px; } .right { background-color: #0f0; height: 500px; overflow: hidden; /*触发bfc达到自适应*/ } 3.利用table实现 .parent{ width: 100%; display: table; height: 500px; } .left { width: 100px; background-color: #f00; } .right { background-color: #0f0; } .left,#right{ display: table-cell; /*利用单元格自动分配宽度*/ } 4.利用绝对定位实现 .parent{ position:relative; } .left { position:absolute; background-color: #f00; width: 100px; height: 500px; } .right { position:absolute; left:100px; right:0px; background-color: #0f0; height: 500px; } 5.利用flex实现 .parent{ display:flex; } .left { background-color: #f00; width: 100px; height: 500px; } .right { flex:1; background-color: #0f0; height: 500px; } 6.利用grid（网格）实现 .parent{ display:grid; grid-template-columns:100px auto; } .left { background-color: #f00; } .right { background-color: #0f0; } 左列自适应，右列定宽1.利用float+margin实现 .parent{ padding-left:100px;//为了抵消margin-left:-100px } .left { width:100%; float:left; margin-left:-100px; background-color: #f00; } .right { width:100px; float:right; background-color: #0f0; } 2.利用float+overflow实现 //这里左右列的标签要换一下 &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;right&quot;&gt;右列定宽&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左列自适应&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; .left { overflow: hidden; /*触发bfc*/ background-color: #f00; } .right { float: right; width: 100px; background-color: #0f0; } 3.利用table实现 .parent{ display:table; width:100%; } .left { display:table-cell; background-color: #ff0; } .right { display:table-cell; width: 100px; background-color: #0f0; } 4.利用绝对定位实现 .parent{ position:relative; } .left { position:absolute; right:100px; left:0px; background-color: #ff0; } .right { position:absolute; right:0px; width: 100px; background-color: #0f0; } 5.利用flex实现 .parent{ display:flex; } .left { flex:1; background-color: #f00; } .right { width: 100px; background-color: #0f0; } 6.利用grid实现 .parent{ display:grid; grid-template-columns:auto 100px; } .left { background-color: #ff0; } .right { background-color: #0f0; } 左列不定宽，右列自适应1.利用float+overflow实现 .left { float:left; background-color: #f00; } .right { overflow:hidden; background-color: #0f0; } 2.利用flex实现 .parent{ display:flex; } .left { background-color: #ff0; } .right { flex:1; background-color: #0f0; } 3.利用grid实现 .parent{ display:grid; grid-template-columns:auto 1fr; } .left { background-color: #f00; } .right { flex:1; background-color: #0f0; }]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2018%2F08%2F28%2FES6%2F</url>
    <content type="text"><![CDATA[函数总体规则 不在函数内定义的变量具有全局作用域，所有的全局作用域变量被绑定到window的一个属性 内部函数变量可以访问外部函数变量 如果内部函数变量和外部函数变量名相同，内部函数变量会屏蔽外部函数变量 let块级作用域变量用var声明的变量作用于函数内部： function foo() { for (var i=0; i&lt;100; i++) { } i += 100; // 仍然可以引用变量i } 用let声明的变量： function foo() { var sum = 0; for (let i=0; i&lt;100; i++) { sum += i; } // SyntaxError:这里会报错 i += 1; } 注：const是具有块级作用域的常量，通常大写表示 解构赋值对多个变量进行赋值： var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;]; 多个变量嵌套赋值： let [x, [y, z]] = [&apos;hello&apos;, [&apos;JavaScript&apos;, &apos;ES6&apos;]]; 取一个对象中的若干数据赋值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos; }; var {name, age, passport} = person;//这里name,age,passport会分别被赋值对应属性 取一个对象中的数据，进行嵌套赋值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos;, address: { city: &apos;Beijing&apos;, street: &apos;No.1 Road&apos;, zipcode: &apos;100001&apos; } }; var {name, address: {city, zip}} = person;//city,zip被赋值 //注意：这里的address不是变量，而是为了获得里面的数据对象的属性，直接访问会报not defined错误 如果变量对应的属性不存在，变量将被赋值为undefined。如果要使用变量名和属性名不一样，可以使用下面的语句： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos;, school: &apos;No.4 middle school&apos; }; // 把passport属性赋值给变量id: let {name, passport:id} = person;//id=&apos;G-123456&apos; //注意这里的passport也不是变量，和address类似。 解构赋值使用默认值： var person = { name: &apos;小明&apos;, age: 20, gender: &apos;male&apos;, passport: &apos;G-12345678&apos; }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; Array的相关高阶函数map()方法定义在JavaScript的Array中，用来对Array中的每个元素进行相同的操作，比如对Array中的每个元素进行求平方： function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] console.log(results); reduce（）方法也是定义在JavaScript的Array中，reduce()把结果继续和序列的下一个元素做累计计算，比如对Array中的数组求和： var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 filter()函数用于把Array的某些元素过滤掉，然后返回剩下的元素。比如删掉Array中的偶数，只保留奇数: var arr = [1, 2, 4, 5, 6, 9, 10, 15]; var r = arr.filter(function (x) { return x % 2 !== 0; }); r; // [1, 5, 9, 15] sort()函数用于排序。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1 //注意：sort()方法默认把所有元素先转换为String，然后在根据字符的ASCII码进行排序 sort()可以接受一个比较函数来实现自定义排序，比如对一个数组按数字大小排序： var arr = [10, 20, 1, 2]; arr.sort(function (x, y) { if (x &lt; y) { return -1; } if (x &gt; y) { return 1; } return 0; }); console.log(arr); // [1, 2, 10, 20] generator（生成器）generator生成器是ES6标准引入的新的数据类型。由function*定义，并且，除了return语句，还可以用yield返回多次。 比如利用generator函数生成一个斐波那契数列，它由0，1开头：0 1 1 2 3 5 8 13 21 34 … function* fib(max) { var t, a = 0, b = 1, n = 0; while (n &lt; max) { yield a; [a, b] = [b, a + b]; n ++; } return; } 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法 var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} 第二个方法是直接用for … of循环迭代generator对象，这种方式不需要我们自己判断done： for (var x of fib(5)) { console.log(x); // 依次输出0, 1, 1, 2, 3, ... } 面向对象编程class继承1.子类必须在constructor方法中调用super方法 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class Student1 { constructor(name) { this.name = name; } hello() { alert(&apos;Hello, &apos; + this.name); } } class PrimaryStudent1 extends Student1 { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert(&apos;I am at grade &apos; + this.grade); } } var myStudent = new PrimaryStudent1(&apos;this is name1&apos;,&apos;this is grade1&apos;) myStudent.hello();// hello,this is name1 myStudent.myGrade();//I am at grade this is grade1 Promise在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。 一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败： function test(resolve, reject) { var timeOut = Math.random() * 2; log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;); setTimeout(function () { if (timeOut &lt; 1) { log(&apos;call resolve()...&apos;); resolve(&apos;200 OK&apos;); } else { log(&apos;call reject()...&apos;); reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;); } }, timeOut * 1000); } new Promise(test).then(function (result) { console.log(&apos;成功：&apos; + result); }).catch(function (reason) { console.log(&apos;失败：&apos; + reason); }); Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写： job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是Promise对象。 resolve 表示异步操作执行成功后的回调函数，reject 表示异步操作执行失败后的回调函数。 then接收resovle传递的数据，catch接收reject传递的数据。 next( 1 ).then( function( res ){ console.log( &apos;resolve:&apos; +res ); } ).catch( function( res ){ console.log( &apos;reject:&apos; + res ); } ); 字符串ES6模板语法连接字符串: var name = &apos;小明&apos;; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; alert(message); 获取字符串的长度： var s = &apos;Hello, world!&apos;; s.length; // 13 获取字符串某个指定位置字符, .charAt()方法有相同的功能： var s = &apos;Hello, world!&apos;; s[0]; // &apos;H&apos; s[6]; // &apos; &apos; s[7]; // &apos;w&apos; s[12]; // &apos;!&apos; s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined //注意：空字符也占一个位置。同时字符串是不可变的，如果对字符串某个索引赋值，不会有任何效果。 字符串方法：调用这些方法本身不会改变原有字符串的内容，而是返回一个新的字符串charAt()返回指定位置的字符 charCodeAt()返回指定位置的字符的Unicode编码 toUpperCase()把一个字符串全部变为大写 toLowerCase()把一个字符串全部变为小写 indexOf()搜索指定字符串出现的位置： var s = &apos;hello, world&apos;; s.indexOf(&apos;world&apos;); // 返回7 s.indexOf(&apos;World&apos;); // 没有找到指定的子串 lastIndexOf()返回字符串最后出现的位置 substring()返回指定索引区间的子串： var s = &apos;hello, world&apos; s.substring(0, 5); // **从索引0开始到5（不包括5）**，返回&apos;hello&apos; s.substring(7); // 从索引7开始到结束，返回&apos;world&apos; split(separator,howmany)按分隔符分割字符串数组，第一个参数必需，分割符，第二个参数可选，表示返回新字符串数组的最大长度： var str=&apos;How are you?&apos; str.split(&apos; &apos;) //How,are,you? str.split(&apos;&apos;) //H,o,w, ,a,r,e, ,y,o,u,? str.split(&apos; &apos;,2) //How,are trim()去掉字符串首尾的空格 var greeting = &apos; Hello world! &apos;; console.log(greeting.trim()); // expected output: &quot;Hello world!&quot;; 数组方法indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;]; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;] arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] // 只删除,不添加: arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;] arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;] // 只添加,不删除: arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素 arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] //如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： push()和pop() push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： var arr = [1, 2]; arr.push(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4 arr; // [1, 2, &apos;A&apos;, &apos;B&apos;] arr.pop(); // pop()返回&apos;B&apos; arr; // [1, 2, &apos;A&apos;] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] unshift()和shift() 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： var arr = [1, 2]; arr.unshift(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4 arr; // [&apos;A&apos;, &apos;B&apos;, 1, 2] arr.shift(); // &apos;A&apos; arr; // [&apos;B&apos;, 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] sort()sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序： var arr = [&apos;B&apos;, &apos;C&apos;, &apos;A&apos;]; arr.sort(); arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] reversereverse()把整个Array的元素给掉个个，也就是反转： var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]; arr.reverse(); arr; // [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; var added = arr.concat([1, 2, 3]); added; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3] arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] //注意concat()方法并没有修改当前Array，而是返回了一个新的Array。 joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3]; arr.join(&apos;-&apos;); // &apos;A-B-C-1-2-3&apos; includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 var array1 = [1, 2, 3]; console.log(array1.includes(2)); // expected output: true MapMap是一组键值对的结构，具有极快的查找速度。 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 循环for…infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来： var o = { name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos; }; for (var key in o) { console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos; } for…of循环是ES6引入的新的语法: var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]); var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]); for (var x of a) { // 遍历Array console.log(x); } for (var x of s) { // 遍历Set console.log(x); } for (var x of m) { // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]); } forEach更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + &apos;, index = &apos; + index); }); 浏览器对象windowwindows对象不但充当全局作用域，而且表示浏览器窗口。 window.innerWidth浏览器窗口内部宽度，window.outerwidth浏览器窗口整个宽度。window.innerHeight浏览器窗口内部高度，window.outerHeight浏览器窗口整个高度//外部是浏览器窗口整个的大小，内部窗口是页面能显示的窗口大小。 navigatornavigator对象表示浏览器的信息。 navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 screenscrenn对象表示屏幕的信息。 screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。//如果你的windows把屏幕放大为125%，那么1920x1080的屏幕会显示为1536x864。 locationlocation对象表示当前页面的URL信息。例如，一个完整的URL： http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： location.protocol; // &apos;http&apos; location.host; // &apos;www.example.com&apos; location.port; // &apos;8080&apos; location.pathname; // &apos;/path/index.html&apos; location.search; // &apos;?a=1&amp;b=2&apos; location.hash; // &apos;TOP&apos; location.origin //http://www.example.com location.href// http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，可以调用location.reload()。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
