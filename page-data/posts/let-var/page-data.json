{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/let-var","result":{"data":{"markdownRemark":{"id":"62cfc41a-6684-5c26-beb8-44a46fc23c61","html":"<h1 id=\"let\" style=\"position:relative;\"><a href=\"#let\" aria-label=\"let permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>let：</h1>\n<p>声明的 let 变量只作于于代码块内部，外部访问会报变量没有被定义的错误。</p>\n<p>而 var 变量在没有声明时访问，只会返回 undefined，并不会报错。</p>\n<p>什么叫代码块内部昵？简单来说就是被{}所包裹的内容。</p>\n<p>当在（）中声明的 let 变量，也只能在它后面的{}中访问。即{}可以看做 let 作用域的子作用域。</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">var a = 1;\n{\n    var b = 2;\n    let c = 3;\n}\n或\nfor (var b1 = 1 ; b1&lt;=3;b1++) {\n    console.log(b1)\n}\nfor (let c1 = 1; c1 &lt;= 3; c1++) {\n    console.log(c1)\n}\n//这里的a、b、b1都能在外部访问。而c、c1只能在内部访问。</code>\n        </deckgo-highlight-code>\n<!--more-->\n<p>变量提升：当声明的 var 变量，变量会自动提升为全局变量。不管是在函数外部还是在函数内部，只要在定义之后都可以访问。</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">for (var b1 = 1 ; b1&lt;=3;b1++) {\n    console.log(b1);\n    console.log(b2);\n    for (var b2 =1; b2 &lt;=3; b2++) {\n        console.log(b1);\n        console.log(b2)\n    }\n    console.log(&quot;------------------------------------&quot;)\n}\nconsole.log(b1)\nconsole.log(b2)\n//这里都能访问b1,b2。只是在内部第一层第一次访问b2时会返回undifined。</code>\n        </deckgo-highlight-code>\n<p>对应的用 let 声明：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">for (let c1 = 1; c1 &lt;= 3; c1++) {\n    console.log(c1)\n    for (let c2=1; c2&lt;=3; c2++) {\n        console.log(c1)\n        console.log(c2)\n    }\n    console.log(&quot;------------------------------------&quot;)\n}\n//这里内部第二层可以访问到c1,也就是说这里的作用域包括了它的子作用域。</code>\n        </deckgo-highlight-code>\n<p><strong>var 变量名相同时：</strong></p>\n<p>同层：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">var a =1\nvar a =2\n//a=2，即他们共享内存地址。</code>\n        </deckgo-highlight-code>\n<p>不同层：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">for (var b1 = 1 ; b1&lt;=3;b1++) {\n    console.log(b1);\n    console.log(b1);\n    for (var b1 =1; b1 &lt;=3; b1++) {\n        console.log(b1);\n        console.log(b1)\n    }\n    console.log(&quot;------------------------------------&quot;)\n}\nconsole.log(b1)\nconsole.log(b1)\n//第一层b1和第二层b2共享内存地址。\n//这里外部循环只会执行一次，即内部循环跳出时，外部的第二次循环b2的值已经是4。\n//由于for循环特性，依然会执行b++，所以最后输出的b1的值为5</code>\n        </deckgo-highlight-code>\n<p><strong>let 变量名相同时：</strong></p>\n<p>同层：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">let a =1\nlet a =2\nconsole.log(a)\n//会报错，提示&#39;a&#39;has already been declared</code>\n        </deckgo-highlight-code>\n<p>不同层：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">for (let c1 = 1; c1 &lt;= 3; c1++) {\n    console.log(c1)\n    for (let c1=1; c1&lt;=3; c1++) {\n        console.log(c1)\n        console.log(c1)\n    }\n    console.log(&quot;------------------------------------&quot;)\n}\n//\n//第一层c1和第二层c1有单独的内存地址。\n//这里第一层和第二层的c1名字虽然是一样的，但是在自己的块内只访问自己的变量。\n//即第一层只访问第一层的变量，第二层访问第二层的变量。相互之间不影响。</code>\n        </deckgo-highlight-code>\n<p>**var 变量于 let 变量同名时： **</p>\n<p>同层：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">var b =1\nlet b =7\nconsole.log(b)\n//会报错，&#39;b&#39; has already been declared\n\nlet b =1\nvar b=7\n//会报错，&#39;b&#39; has already been declared\n\nfor (let b1 = 1; b1 &lt;= 3; b1++) {\n    var b1 = 7;\n    console.log(b1)\n}\n//这样写也会报错\n\nfor (var b1 = 1; b1 &lt;= 3; b1++) {\n    let b1 = 7;\n    console.log(b1)\n}\n//按理来说，这样也应该叫同层，会报错。但是不会，会正常的输出三个7。</code>\n        </deckgo-highlight-code>\n<p>不同层：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">var b =1\nfor (let b=1;b&lt;=3;b++) {\n    console.log(b)\n}\nconsole.log(b)\n//正常输出\n\nlet b =1\nfor (var b=1;b&lt;=3;b++) {\n    console.log(b)\n}\nconsole.log(b)\n//会报错，&#39;b&#39; has already been declared\n\nfor (var b1 = 1; b1 &lt;= 3; b1++) {\n    let b1 = 7;\n    console.log(b1)\n}\nconsole.log(b1)\n//正常输出\n\nfor (let b1 =1;b1&lt;=3;b1++) {\n    var b1 = 7\n    console.log(b1)\n}\n//会报错，&#39;b&#39; has already been declared</code>\n        </deckgo-highlight-code>\n<p><strong>综上述，可得出结论：</strong></p>\n<font color=\"#dd0000\">\n1. for（）里面的域可以看作是它外部域的子域，是它后面{}的父域。\n2. var可以设置同名变量，因为会自动提升为全局变量，共享内存地址。\n3. let同层不可以设置同名变量。\n4. var和let变量名相同时，不可以在同一层。\n5. var和let变量名相同时，var变量可以在let变量的外层，而let变量不能在var变量的外层。\n</font>\n<h1 id=\"const\" style=\"position:relative;\"><a href=\"#const\" aria-label=\"const permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>const：</h1>\n<p><strong>const</strong>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。\n对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。\n但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了</p>\n<p>const 为常量时不可修改，声明时必须要初始化。</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">const a =1\na=2 //报错</code>\n        </deckgo-highlight-code>\n<p>const 为对象或数组时：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">const a = [&quot;1&quot;,&quot;2&quot;]\na.push(&quot;3&quot;)\nconsole.log(a)\n//可以对数组进行修改\n\nfunction f() {\n    console.log(&quot;1&quot;)\n}\nconst a = f()\nfunction f(){\n    console.log(&quot;2&quot;)\n}\n//这里输出&quot;2&quot;，可以对函数对象修改</code>\n        </deckgo-highlight-code>\n<h1 id=\"函数作用域\" style=\"position:relative;\"><a href=\"#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F\" aria-label=\"函数作用域 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>函数作用域：</h1>\n<p><strong>ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用：</strong></p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">function f() {\n    console.log(&quot;f0&quot;);\n    function f(){\n        console.log(&quot;f01&quot;)\n    }\n    f()\n}\nf()\n//输出&quot;f0&quot; &quot;f01&quot;\n\nfunction f() {\n    console.log(&quot;f0&quot;);\n    function f1(){\n        console.log(&quot;f1&quot;)\n    }\n    f1()\n}\nf()\nf1()//到这里的时候报错，外部不能访问内部函数。</code>\n        </deckgo-highlight-code>","fields":{"slug":"/posts/let-var","tagSlugs":["/tag/es-6/"]},"frontmatter":{"date":"2018-12-08 19:01:56","description":"","tags":["ES6"],"title":"let和var不得不说的关系"}},"previous":{"fields":{"slug":"/posts/What-happens-from-the-URL-to-the-page-display"},"frontmatter":{"title":"从URL到页面显示发生了什么"}},"next":{"fields":{"slug":"/posts/Vue-slot"},"frontmatter":{"title":"vue插槽与父子组件传值"}}},"pageContext":{"slug":"/posts/let-var","previousPostSlug":"/posts/What-happens-from-the-URL-to-the-page-display","nextPostSlug":"/posts/Vue-slot"}},"staticQueryHashes":["2281626716","251939775","401334301"]}