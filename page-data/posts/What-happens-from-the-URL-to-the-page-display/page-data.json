{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/What-happens-from-the-URL-to-the-page-display","result":{"data":{"markdownRemark":{"id":"73a34a2a-20d0-5958-b34e-80b54a9fc24b","html":"<h1 id=\"一在浏览器地址栏输入-url\" style=\"position:relative;\"><a href=\"#%E4%B8%80%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-url\" aria-label=\"一在浏览器地址栏输入 url permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一、在浏览器地址栏输入 URL</h1>\n<p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>\n<ol>\n<li>如果资源未缓存，发起新请求</li>\n<li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>\n<li>检验新鲜通常有两个 HTTP 头进行控制 Expires 和 Cache-Control：\n<ul>\n<li>HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期</li>\n<li>HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"二进行-dns-域名解析\" style=\"position:relative;\"><a href=\"#%E4%BA%8C%E8%BF%9B%E8%A1%8C-dns-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90\" aria-label=\"二进行 dns 域名解析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>二、进行 DNS 域名解析</h1>\n<p><strong>浏览器解析 URL 获取协议，主机，端口，PATH。把这些请求组装一个 HTTP（GET）请求报文:</strong></p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">//首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF\n//首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束\n//请求头和消息实体之间有一个CRLF分隔\n//根据实际请求需要可能包含一个消息实体\nGET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\nHost: www.w3.org\nConnection: keep-alive\nCache-Control: max-age=0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\nReferer: https://www.google.com.hk/\nAccept-Encoding: gzip,deflate,sdch\nAccept-Language: zh-CN,zh;q=0.8,en;q=0.6\nCookie: authorstyle=yes\nIf-None-Match: &quot;2cc8-3e3073913b100&quot;\nIf-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\n\nname=qiu&amp;age=25</code>\n        </deckgo-highlight-code>\n<p><strong>浏览器获取主机 ip 地址，解析的查找顺序依次为：</strong></p>\n<p>1.浏览器自身的 DNS 缓存</p>\n<p>2.本机 DNS 缓存 //存放在内存中，关机就消失</p>\n<p>3.hosts 文件 //存放在系统文件夹中</p>\n<p>4.路由器缓存</p>\n<p>5.DNS 域名服务器</p>\n<p>6.根域名服务器。</p>\n<p><strong>DNS 服务器的分级查询：</strong></p>\n<p>主机名.次级域名.顶级域名.根域名 = <a href=\"http://www.google.com.root\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">www.google.com.root</a> //一般 root 会被省略，因为对于所有的域名都是一样的。\n全世界有 13 台根服务器，域名为 a.root-servers.net 到 m.root-servers.net。</p>\n<p>所谓”分级查询”，就是从根域名开始，依次查询每一级域名的 NS 记录，直到查到最终的 IP 地址，过程大致如下：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">1.从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的NS记录和A记录（IP地址）\n2.从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的NS记录和A记录（IP地址）\n3.从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的IP地址\n//NS记录（Name Server的缩写），即哪些服务器负责管理google.com的DNS记录。</code>\n        </deckgo-highlight-code>\n<p>根域名服务器分布：</p>\n<p><img src=\"https://i.imgur.com/IW1A84s.png\" alt=\"\"></p>\n<p><strong>查找方式分为两种：</strong></p>\n<p>迭代和递归。简单来说，迭代查询就是需要本地服务器自己去找，而递归查询是其它其它服务器直接把查询好的结果告诉它。\n<img src=\"https://i.imgur.com/RVQ3Uxv.png\" alt=\"\"></p>\n<h1 id=\"三根据目标-ip-地址端口建立-tcp-链接\" style=\"position:relative;\"><a href=\"#%E4%B8%89%E6%A0%B9%E6%8D%AE%E7%9B%AE%E6%A0%87-ip-%E5%9C%B0%E5%9D%80%E7%AB%AF%E5%8F%A3%E5%BB%BA%E7%AB%8B-tcp-%E9%93%BE%E6%8E%A5\" aria-label=\"三根据目标 ip 地址端口建立 tcp 链接 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>三、根据目标 IP 地址，端口建立 TCP 链接</h1>\n<p><strong>进行 TCP 协议三次握手：</strong></p>\n<p>1.主机向服务器发送一个建立连接的请求（您好，我想认识您）； 2.服务器接到请求后发送同意连接的信号（好的，很高兴认识您）； 3.主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。\n//结束断开的时候为四次挥手</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口\n服务器发回SYN=1， ACK=X+1， Seq=Y的响应包\n客户端发送ACK=Y+1， Seq=Z</code>\n        </deckgo-highlight-code>\n<h1 id=\"四服务器将响应报文返回-http-报文给浏览器\" style=\"position:relative;\"><a href=\"#%E5%9B%9B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%86%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E8%BF%94%E5%9B%9E-http-%E6%8A%A5%E6%96%87%E7%BB%99%E6%B5%8F%E8%A7%88%E5%99%A8\" aria-label=\"四服务器将响应报文返回 http 报文给浏览器 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>四、服务器将响应报文，返回 HTTP 报文给浏览器</h1>\n<p><strong>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序</strong></p>\n<p><strong>服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回 304 等对应状态码</strong></p>\n<p><strong>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作</strong></p>\n<p><strong>服务器将响应报文通过 TCP 连接发送回浏览器</strong></p>\n<p>返回的 HTTP 报文如下：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">//首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF\n//首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束\n//请求头和消息实体之间有一个CRLF分隔\n//根据实际请求需要可能包含一个消息实体 一个请求报文例子如下：\n\nGET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\nHost: www.w3.org\nConnection: keep-alive\nCache-Control: max-age=0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\nReferer: https://www.google.com.hk/\nAccept-Encoding: gzip,deflate,sdch\nAccept-Language: zh-CN,zh;q=0.8,en;q=0.6\nCookie: authorstyle=yes\nIf-None-Match: &quot;2cc8-3e3073913b100&quot;\nIf-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\n\n&lt;html&gt;\n      &lt;head&gt;&lt;/head&gt;\n      &lt;body&gt;\n            &lt;!--body goes here--&gt;\n      &lt;/body&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<h1 id=\"五浏览器解析渲染页面\" style=\"position:relative;\"><a href=\"#%E4%BA%94%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2\" aria-label=\"五浏览器解析渲染页面 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>五、浏览器解析渲染页面</h1>\n<p>**浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下： **</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">主动方发送Fin=1， Ack=Z， Seq= X报文\n被动方发送ACK=X+1， Seq=Z报文\n被动方发送Fin=1， ACK=X， Seq=Y报文\n主动方发送ACK=Y， Seq=X报文</code>\n        </deckgo-highlight-code>\n<p>浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同</p>\n<p>如果资源可缓存，进行缓存</p>\n<p>对响应进行解码（例如 gzip 压缩）</p>\n<p>根据资源类型决定如何处理（假设资源为 HTML 文档）</p>\n<p><strong>解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本：</strong></p>\n<p>构建 DOM 树：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">Tokenizing：根据HTML规范将字符流解析为标记\nLexing：词法分析将标记转换为对象并定义属性和规则\nDOM construction：根据HTML标记关系将对象组成DOM树</code>\n        </deckgo-highlight-code>\n<p>解析过程中遇到图片、样式表、js 文件，启动下载</p>\n<p>构建 CSSOM 树：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">Tokenizing：字符流转换为标记流\nNode：根据标记创建节点\nCSSOM：节点创建CSSOM树</code>\n        </deckgo-highlight-code>\n<p>根据 DOM 树和 CSSOM 树构建渲染树:</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none\n对每一个可见节点，找到恰当的CSSOM规则并应用\n发布可视节点的内容和计算样式</code>\n        </deckgo-highlight-code>\n<p>js 解析：</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading\nHTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容\n当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素\n当文档完成解析，document.readState变成interactive\n所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()\n浏览器在Document对象上触发DOMContentLoaded事件\n此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件</code>\n        </deckgo-highlight-code>\n<p>显示页面（HTML 解析过程中会逐步显示页面）</p>","fields":{"slug":"/posts/What-happens-from-the-URL-to-the-page-display","tagSlugs":["/tag/计算机网络/"]},"frontmatter":{"date":"2018-11-22 15:49:37","description":"German inventor Johannes Gutenberg developed a method of movable type and used it to create one of the western world’s first major printed books, the “Forty–Two–Line” Bible.","tags":["计算机网络"],"title":"从URL到页面显示发生了什么"}},"previous":{"fields":{"slug":"/posts/binary-tree"},"frontmatter":{"title":"二叉树相关"}},"next":{"fields":{"slug":"/posts/let-var"},"frontmatter":{"title":"let和var不得不说的关系"}}},"pageContext":{"slug":"/posts/What-happens-from-the-URL-to-the-page-display","previousPostSlug":"/posts/binary-tree","nextPostSlug":"/posts/let-var"}},"staticQueryHashes":["2281626716","251939775","401334301"]}